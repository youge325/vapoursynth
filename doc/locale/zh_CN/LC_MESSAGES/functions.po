# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2025, Fredrik Mellbin
# This file is distributed under the same license as the VapourSynth
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: VapourSynth R74\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 21:20+0800\n"
"PO-Revision-Date: 2026-02-20 21:45+0800\n"
"Last-Translator: VapourSynth Translation Team\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.16.0\n"

#: ../../functions.rst:2
msgid "Function Reference"
msgstr "函数参考"

#: ../../functions.rst:5
msgid "General Functions"
msgstr "通用函数"

#: ../../functions.rst:14
msgid "Video Functions"
msgstr "视频函数"

#: ../../functions.rst:23 ../../functions/video/text/text.rst:2
msgid "Text"
msgstr "文本"

#: ../../functions.rst:32
msgid "Audio Functions"
msgstr "音频函数"

#: ../../functions/audio/assumesamplerate.rst:2
msgid "AssumeSampleRate"
msgstr "AssumeSampleRate"

#: ../../functions/audio/audiogain.rst:2
msgid "AudioGain"
msgstr "AudioGain"

#: ../../functions/audio/audiogain.rst:7
msgid ""
"AudioGain can either change the volume of individual channels if a separate "
"*gain* for each channel is given or if only a single *gain* value is "
"supplied it's applied to all channels."
msgstr "AudioGain 可以为每个通道指定单独的 *gain* 来改变各通道的音量，如果只提供一个 *gain* 值则应用于所有通道。"

#: ../../functions/audio/audiogain.rst:11
msgid ""
"Negative *gain* values are allowed. Applying a too large gain will lead to "
"clipping in integer formats."
msgstr "允许负 *gain* 值。使用过大的增益会导致整数格式中的削波。"

#: ../../functions/audio/audiogain.rst:14
#: ../../functions/audio/audiomix.rst:24
msgid ""
"Will stop processing with an error if clipping is detected if "
"*overflow_error* is set. If it's false a warning will be printed for the "
"first audio block with clipping."
msgstr "如果设置了 *overflow_error*，检测到削波时将停止处理并报错。如果为 false，则会为第一个有削波的音频块打印警告。"

#: ../../functions/audio/audioloop.rst:2
msgid "AudioLoop"
msgstr "AudioLoop"

#: ../../functions/audio/audioloop.rst:7 ../../functions/video/loop.rst:7
msgid ""
"Returns a clip with the frames or samples repeated over and over again. If "
"*times* is less than 1 the clip will be repeated until the maximum clip "
"length is reached, otherwise it will be repeated *times* times."
msgstr "返回帧或采样重复播放的片段。如果 *times* 小于 1，片段将重复直到达到最大片段长度，否则将重复 *times* 次。"

#: ../../functions/audio/audioloop.rst:11
msgid ""
"In Python, std.AudioLoop can also be invoked :ref:`using the multiplication "
"operator <pythonreference>`."
msgstr "在 Python 中，std.AudioLoop 也可以通过 :ref:`乘法运算符 <pythonreference>` 调用。"

#: ../../functions/audio/audiomix.rst:2
msgid "AudioMix"
msgstr "AudioMix"

#: ../../functions/audio/audiomix.rst:7
msgid ""
"AudioMix can mix and combine channels from different clips in the most "
"general way possible."
msgstr "AudioMix 可以以最通用的方式混合和组合不同片段的通道。"

#: ../../functions/audio/audiomix.rst:10
#: ../../functions/audio/shufflechannels.rst:10
msgid ""
"Most of the returned clip's properties are implicitly determined from the "
"first clip given to *clips*."
msgstr "返回片段的大多数属性由给定到 *clips* 的第一个片段隐式确定。"

#: ../../functions/audio/audiomix.rst:13
#: ../../functions/audio/shufflechannels.rst:13
msgid ""
"The *clips* parameter takes one or more clips with the same format. If the "
"clips are different lengths they'll be zero extended to that of the longest."
msgstr "*clips* 参数接受一个或多个相同格式的片段。如果片段长度不同，将零填充至最长片段的长度。"

#: ../../functions/audio/audiomix.rst:16
msgid ""
"The argument *matrix* applies the coefficients to each channel of each input"
" clip where the channels are in the numerical order of their channel "
"constants. For example a stereo clip will have its channels presented in the"
" order FRONT_LEFT and then FRONT_RIGHT."
msgstr ""
"*matrix* 参数将系数应用于每个输入片段的每个通道，通道按其通道常量的数值顺序排列。例如，立体声片段的通道将按 FRONT_LEFT 然后 "
"FRONT_RIGHT 的顺序呈现。"

#: ../../functions/audio/audiomix.rst:20
msgid ""
"Output channels and order is determined by the *channels_out* array between "
"input index and output channel happens on the order of lowest output channel"
" identifier to the highest."
msgstr "输出通道和顺序由 *channels_out* 数组决定，输入索引和输出通道之间的映射按从最低到最高的输出通道标识符顺序进行。"

#: ../../functions/audio/audiomix.rst:29
#: ../../functions/audio/shufflechannels.rst:28
#: ../../functions/video/selectevery.rst:10
#: ../../functions/video/shuffleplanes.rst:31
msgid "Below are some examples of useful operations."
msgstr "以下是一些有用的操作示例。"

#: ../../functions/audio/audiomix.rst:31
msgid "Downmix stereo audio to mono::"
msgstr "将立体声音频下混为单声道："

#: ../../functions/audio/audiomix.rst:35
msgid "Downmix 5.1 audio::"
msgstr "下混 5.1 音频："

#: ../../functions/audio/audiomix.rst:39
msgid "Copy stereo audio to 5.1 and zero the other channels::"
msgstr "将立体声音频复制到 5.1 并将其他通道置零："

#: ../../functions/audio/audioreverse.rst:2
msgid "AudioReverse"
msgstr "AudioReverse"

#: ../../functions/audio/audioreverse.rst:7
#: ../../functions/video/reverse.rst:7
msgid ""
"Returns a clip with the frame or sample order reversed. For example, a clip "
"with 3 frames would have the frame order 2, 1, 0."
msgstr "返回帧或采样顺序反转的片段。例如，有 3 帧的片段将变为 2、1、0 的帧顺序。"

#: ../../functions/audio/audioreverse.rst:10
msgid ""
"In Python, std.AudioReverse can also be invoked by :ref:`slicing a clip "
"<pythonreference>`."
msgstr "在 Python 中，std.AudioReverse 也可以通过 :ref:`切片 <pythonreference>` 调用。"

#: ../../functions/audio/audiosplice.rst:2
msgid "AudioSplice"
msgstr "AudioSplice"

#: ../../functions/audio/audiosplice.rst:7 ../../functions/video/splice.rst:7
msgid "Returns a clip with all *clips* appended in the given order."
msgstr "返回按给定顺序附加所有 *clips* 的片段。"

#: ../../functions/audio/audiosplice.rst:9
msgid ""
"Splicing clips with different formats or dimensions is considered an error."
msgstr "拼接不同格式或维度的片段将被视为错误。"

#: ../../functions/audio/audiosplice.rst:12
msgid ""
"In Python, std.AudioSplice can also be invoked :ref:`using the addition "
"operator <pythonreference>`."
msgstr "在 Python 中，std.AudioSplice 也可以通过 :ref:`加法运算符 <pythonreference>` 调用。"

#: ../../functions/audio/audiotrim.rst:2
msgid "AudioTrim"
msgstr "AudioTrim"

#: ../../functions/audio/audiotrim.rst:7
msgid ""
"AudioTrim performs exactly the same operation on audio clips but the unit is"
" obviously samples instead of frames."
msgstr "AudioTrim 对音频片段执行完全相同的操作，但单位是采样而非帧。"

#: ../../functions/audio/audiotrim.rst:10
msgid ""
"In Python, std.AudioTrim can also be invoked by :ref:`slicing a clip "
"<pythonreference>`."
msgstr "在 Python 中，std.AudioTrim 也可以通过 :ref:`切片 <pythonreference>` 调用。"

#: ../../functions/audio/blankaudio.rst:2
msgid "BlankAudio"
msgstr "BlankAudio"

#: ../../functions/audio/blankaudio.rst:7
msgid ""
"Generates a new empty clip. This can be useful to have when editing audio or"
" for testing. The default is a 10 second long 44.1kHz 16 bit stereo clip. "
"Instead of specifying every property individually, BlankAudio can also copy "
"the properties from *clip*. If both an argument such as *sampletype*, and "
"*clip* are set, then *sampletype* will take precedence."
msgstr ""
"生成一个新的空片段。这在编辑音频或测试时很有用。默认是一个 10 秒长的 44.1kHz 16 位立体声片段。BlankAudio 也可以从 "
"*clip* 复制属性，而无需单独指定每个属性。如果同时设置了 *sampletype* 等参数和 *clip*，则 *sampletype* 优先。"

#: ../../functions/audio/blankaudio.rst:13
msgid ""
"The *channels* argument is a list of channel constants. Specifying the same "
"channel twice is not allowed."
msgstr "*channels* 参数是通道常量的列表。不允许指定相同的通道两次。"

#: ../../functions/audio/blankaudio.rst:16
msgid ""
"The possible *sampletype* values are currently INTEGER (0) and FLOAT (1)."
msgstr "目前可能的 *sampletype* 值为 INTEGER (0) 和 FLOAT (1)。"

#: ../../functions/audio/blankaudio.rst:18
#: ../../functions/video/blankclip.rst:13
msgid ""
"If *keep* is set, a reference to the same frame is returned on every "
"request. Otherwise a new frame is generated every time. There should usually"
" be no reason to change this setting."
msgstr "如果设置了 *keep*，每次请求都返回对同一帧的引用。否则每次都生成新帧。通常没有理由更改此设置。"

#: ../../functions/audio/setaudiocache.rst:2
msgid "SetAudioCache"
msgstr "SetAudioCache"

#: ../../functions/audio/setaudiocache.rst:7
msgid "see SetVideoCache"
msgstr "参见 SetVideoCache"

#: ../../functions/audio/shufflechannels.rst:2
msgid "ShuffleChannels"
msgstr "ShuffleChannels"

#: ../../functions/audio/shufflechannels.rst:7
msgid ""
"ShuffleChannels can extract and combine channels from different clips in the"
" most general way possible."
msgstr "ShuffleChannels 可以以最通用的方式从不同片段中提取和组合通道。"

#: ../../functions/audio/shufflechannels.rst:16
msgid ""
"The argument *channels_in* controls which of the input clips' channels to "
"use and takes a channel constants as its argument. Specifying a non-existent"
" channel is an error. If more *channels_in* than *clips* values are "
"specified then the last clip in the *clips* list is reused as a source. In "
"addition to the channel constant it's also possible to specify the nth "
"channel by using negative numbers."
msgstr ""
"*channels_in* 参数控制使用输入片段的哪些通道，接受通道常量作为参数。指定不存在的通道是错误的。如果指定的 *channels_in* 多于"
" *clips* 值，则 *clips* 列表中的最后一个片段将被重用作源。除了通道常量之外，还可以使用负数来指定第 n 个通道。"

#: ../../functions/audio/shufflechannels.rst:22
msgid ""
"The output channel mapping is determined by *channels_out* and corresponds "
"to the input channel order. The number of *channels_out* entries must be the"
" same as the number of *channels_in* entries. Specifying the same output "
"channel twice is an error."
msgstr ""
"输出通道映射由 *channels_out* 决定，对应输入通道顺序。*channels_out* 条目数必须与 *channels_in* "
"条目数相同。指定相同的输出通道两次是错误的。"

#: ../../functions/audio/shufflechannels.rst:30
msgid "Extract the left channel (assuming it exists)::"
msgstr "提取左声道（假设存在）："

#: ../../functions/audio/shufflechannels.rst:34
msgid "Swap left and right audio channels in a stereo clip::"
msgstr "交换立体声片段中的左右声道："

#: ../../functions/audio/shufflechannels.rst:38
msgid ""
"Swap left and right audio channels in a stereo clip (alternate ordering of "
"arguments)::"
msgstr "交换立体声片段中的左右声道（参数顺序的替代写法）："

#: ../../functions/audio/shufflechannels.rst:42
msgid ""
"Swap left and right audio channels in a stereo clip (alternate indexing)::"
msgstr "交换立体声片段中的左右声道（替代索引方式）："

#: ../../functions/audio/shufflechannels.rst:46
msgid "Merge 2 mono audio clips into a single stereo clip::"
msgstr "将 2 个单声道音频片段合并为一个立体声片段："

#: ../../functions/audio/splitchannels.rst:2
msgid "SplitChannels"
msgstr "SplitChannels"

#: ../../functions/audio/splitchannels.rst:7
msgid ""
"SplitChannels returns each audio channel of the input as a separate clip."
msgstr "SplitChannels 将输入的每个音频通道作为单独的片段返回。"

#: ../../functions/general/loadallplugins.rst:2
msgid "LoadAllPlugins"
msgstr "LoadAllPlugins"

#: ../../functions/general/loadallplugins.rst:7
msgid ""
"Loads all native VapourSynth plugins found in the specified *path*. Plugins "
"that fail to load are silently skipped."
msgstr "加载在指定 *path* 中找到的所有原生 VapourSynth 插件。加载失败的插件将被静默跳过。"

#: ../../functions/general/loadallplugins.rst:11
#: ../../functions/general/loadplugin.rst:18
#: ../../functions/general/loadpluginavs.rst:36
msgid "Beware of Python's escape character, this will fail::"
msgstr "注意 Python 的转义字符，以下写法将失败："

#: ../../functions/general/loadallplugins.rst:15
#: ../../functions/general/loadplugin.rst:22
#: ../../functions/general/loadpluginavs.rst:40
msgid "Correct ways::"
msgstr "正确的写法："

#: ../../functions/general/loadplugin.rst:2
msgid "LoadPlugin"
msgstr "LoadPlugin"

#: ../../functions/general/loadplugin.rst:7
msgid ""
"Load a native VapourSynth plugin. If successful, the loaded plugin's "
"functions will end up in their own namespace."
msgstr "加载一个原生 VapourSynth 插件。如果成功，加载的插件函数将位于其自己的命名空间中。"

#: ../../functions/general/loadplugin.rst:10
msgid ""
"Returns an error if a plugin with the same identifier or namespace already "
"has been loaded. This is to prevent naming collisions or multiple versions "
"of the same plugin being loaded at once."
msgstr "如果已加载具有相同标识符或命名空间的插件，将返回错误。这是为了防止命名冲突或同时加载同一插件的多个版本。"

#: ../../functions/general/loadplugin.rst:14
msgid ""
"Plugins are normally loaded with a very specific search order for "
"dependencies. Setting *altsearchpath* modifies this behavior to also include"
" dlls in the PATH."
msgstr "插件通常以非常特定的搜索顺序加载依赖项。设置 *altsearchpath* 会修改此行为，使其也包含 PATH 中的 dll。"

#: ../../functions/general/loadpluginavs.rst:2
msgid "LoadPlugin (Avisynth Compatibility)"
msgstr "LoadPlugin（Avisynth 兼容）"

#: ../../functions/general/loadpluginavs.rst:7
msgid ""
"Load an Avisynth 2.5 (32 bit only), 2.6 (32 and 64 bit) or Avisynth+ (32 and"
" 64 bit) plugin. If successful, the loaded plugin's functions will end up in"
" the avs namespace. Note that in the case of Avisynth+ there's no way to use"
" the formats combined with alpha or higher bitdepth packed RGB. "
"Coincidentally there are no plugins that use this in a meaningful way yet."
msgstr ""
"加载 Avisynth 2.5（仅 32 位）、2.6（32 和 64 位）或 Avisynth+（32 和 64 "
"位）插件。如果成功，加载的插件函数将位于 avs 命名空间中。请注意，对于 Avisynth+，无法使用带有 alpha 或更高位深打包 RGB "
"的格式。巧合的是，目前还没有以有意义的方式使用此功能的插件。"

#: ../../functions/general/loadpluginavs.rst:13
msgid ""
"The compatibility module can work with a large number of Avisynth's plugins."
" However, the wrapping is not complete, so the following things will cause "
"problems:"
msgstr "兼容模块可以与大量 Avisynth 插件配合使用。但是，封装并不完整，因此以下情况会导致问题："

#: ../../functions/general/loadpluginavs.rst:17
msgid ""
"The plugin expects YUY2 or RGB32 input. In this case provide input in either"
" YUV422P8 or RGB24 format pass compatpack=True as an argument to the "
"Avisynth function."
msgstr ""
"插件期望 YUY2 或 RGB32 输入。在这种情况下，提供 YUV422P8 或 RGB24 格式的输入，并将 compatpack=True "
"作为参数传递给 Avisynth 函数。"

#: ../../functions/general/loadpluginavs.rst:20
msgid ""
"The plugin tries to call env->invoke(). These calls are ignored when it is "
"safe to do so, but otherwise they will most likely trigger a fatal error."
msgstr "插件尝试调用 env->invoke()。当安全时这些调用会被忽略，否则很可能触发致命错误。"

#: ../../functions/general/loadpluginavs.rst:23
msgid ""
"Plugins trying to read global variables. There are no global variables."
msgstr "插件尝试读取全局变量。系统没有全局变量。"

#: ../../functions/general/loadpluginavs.rst:26
msgid ""
"If there are function name collisions functions will have a number appended "
"to them to make them distinct. For example if three functions are named "
"*func* then they will be named *func*, *func_2* and *func_3*. This means "
"that Avisynth functions that have multiple overloads (rare) will give each "
"overload a different name."
msgstr ""
"如果出现函数名冲突，函数将附加一个数字以使其区分。例如，如果三个函数都命名为 *func*，则它们将命名为 *func*、*func_2* 和 "
"*func_3*。这意味着具有多个重载的 Avisynth 函数（罕见）将为每个重载赋予不同的名称。"

#: ../../functions/general/loadpluginavs.rst:32
msgid ""
"Note that if you are really insane you can load Avisynth's VirtualDub plugin"
" loader and use VirtualDub plugins as well. Function overloads are very "
"common when dealing with VirtualDub."
msgstr ""
"请注意，如果你确实想要，也可以加载 Avisynth 的 VirtualDub 插件加载器并使用 VirtualDub 插件。处理 VirtualDub"
" 时函数重载非常常见。"

#: ../../functions/general/setmaxcpu.rst:2
msgid "SetMaxCPU"
msgstr "SetMaxCPU"

#: ../../functions/general/setmaxcpu.rst:7
msgid ""
"This function is only intended for testing and debugging purposes and sets "
"the maximum used instruction set for optimized functions."
msgstr "此函数仅用于测试和调试目的，设置优化函数使用的最大指令集。"

#: ../../functions/general/setmaxcpu.rst:10
msgid "Possible values for x86: \"avx2\", \"sse2\", \"none\""
msgstr "x86 的可能值：\"avx2\"、\"sse2\"、\"none\""

#: ../../functions/general/setmaxcpu.rst:12
msgid "Other platforms: \"none\""
msgstr "其他平台：\"none\""

#: ../../functions/general/setmaxcpu.rst:14
msgid "By default all supported cpu features are used."
msgstr "默认情况下使用所有支持的 CPU 特性。"

#: ../../functions/video/addborders.rst:2
msgid "AddBorders"
msgstr "AddBorders"

#: ../../functions/video/addborders.rst:7
msgid ""
"Adds borders to frames. The arguments specify the number of pixels to add on"
" each side. They must obey the subsampling restrictions. The newly added "
"borders will be set to *color*."
msgstr "为帧添加边框。参数指定每侧要添加的像素数。它们必须遵守子采样限制。新添加的边框将设置为 *color*。"

#: ../../functions/video/assumefps.rst:2
msgid "AssumeFPS"
msgstr "AssumeFPS"

#: ../../functions/video/assumefps.rst:7
msgid ""
"Returns a clip with the framerate changed. This does not in any way modify "
"the frames, only their metadata."
msgstr "返回帧率已更改的片段。这不会以任何方式修改帧，只修改其元数据。"

#: ../../functions/video/assumefps.rst:10
msgid ""
"The framerate to assign can either be read from another clip, *src*, or "
"given as a rational number with *fpsnum* and *fpsden*."
msgstr "要分配的帧率可以从另一个片段 *src* 读取，或以有理数形式通过 *fpsnum* 和 *fpsden* 给出。"

#: ../../functions/video/assumefps.rst:13
msgid "It is an error to specify both *src* and *fpsnum*."
msgstr "同时指定 *src* 和 *fpsnum* 是错误的。"

#: ../../functions/video/assumefps.rst:15
msgid ""
"AssumeFPS overwrites the frame properties ``_DurationNum`` and "
"``_DurationDen`` with the frame duration computed from the new frame rate."
msgstr "AssumeFPS 用从新帧率计算出的帧持续时间覆盖帧属性 ``_DurationNum`` 和 ``_DurationDen``。"

#: ../../functions/video/averageframes.rst:2
msgid "AverageFrames"
msgstr "AverageFrames"

#: ../../functions/video/averageframes.rst:7
msgid ""
"AverageFrames has two main modes depending on whether one or multiple "
"*clips* are supplied. The filter is named AverageFrames since using ones for"
" weights is an easy way to average many frames together but it can also be "
"seen as a temporal or multiple frame convolution."
msgstr ""
"AverageFrames 有两种主要模式，取决于提供一个还是多个 *clips*。该滤镜命名为 AverageFrames，因为使用 1 "
"作为权重是将多帧平均在一起的简单方法，但它也可以看作是时间域或多帧卷积。"

#: ../../functions/video/averageframes.rst:11
msgid ""
"If multiple *clips* are supplied then the frames from each of the *clips* "
"are multiplied by the respective *weights*, summed together and divided by "
"*scale* before being output. Note that only integer *weights* and *scale* "
"are allowed for integer input formats."
msgstr ""
"如果提供了多个 *clips*，则每个 *clips* 的帧乘以相应的 *weights*，求和后除以 *scale* "
"再输出。请注意，整数输入格式只允许使用整数 *weights* 和 *scale*。"

#: ../../functions/video/averageframes.rst:15
msgid ""
"If a single *clip* is supplied then an odd number of *weights* are needed "
"and they will instead be temporally centered on the current frame of the "
"*clip*. The rest works as multiple *clip* mode with the only difference "
"being that *scenechange* can be set to avoid averaging frames over scene "
"changes. If this happens then all the weights beyond a scene change are "
"instead applied to the frame right before it."
msgstr ""
"如果提供单个 *clip*，则需要奇数个 *weights*，它们将在当前帧的时间上居中。其余工作方式与多 *clip* 模式相同，唯一的区别是可以设置"
" *scenechange* 以避免跨场景变化平均帧。如果发生这种情况，场景变化之外的所有权重将改为应用于其前一帧。"

#: ../../functions/video/averageframes.rst:21
msgid "At most 31 *weights* can be supplied."
msgstr "最多可以提供 31 个 *weights*。"

#: ../../functions/video/binarize_binarizemask.rst:2
msgid "Binarize/BinarizeMask"
msgstr "Binarize/BinarizeMask"

#: ../../functions/video/binarize_binarizemask.rst:8
msgid ""
"Turns every pixel in the image into either *v0*, if it's below *threshold*, "
"or *v1*, otherwise. The *BinarizeMask* version is intended for use on mask "
"clips where all planes have the same value range and only differs in the "
"default values of *v0* and *v1*."
msgstr ""
"将图像中的每个像素转换为 *v0*（低于 *threshold* 时）或 *v1*。*BinarizeMask* "
"版本适用于所有平面具有相同值范围的蒙版片段，仅在 *v0* 和 *v1* 的默认值上有所不同。"

#: ../../functions/video/binarize_binarizemask.rst:13
#: ../../functions/video/convolution.rst:18
#: ../../functions/video/deflate_inflate.rst:10
#: ../../functions/video/deflate_inflate.rst:32
#: ../../functions/video/invert_invertmask.rst:13
#: ../../functions/video/levels.rst:26 ../../functions/video/limiter.rst:9
#: ../../functions/video/median.rst:11
#: ../../functions/video/minimum_maximum.rst:10
#: ../../functions/video/minimum_maximum.rst:44
#: ../../functions/video/prewitt_sobel.rst:14
msgid "*clip*"
msgstr "*clip*"

#: ../../functions/video/binarize_binarizemask.rst:14
#: ../../functions/video/convolution.rst:19
#: ../../functions/video/deflate_inflate.rst:11
#: ../../functions/video/deflate_inflate.rst:33
#: ../../functions/video/invert_invertmask.rst:14
#: ../../functions/video/levels.rst:27 ../../functions/video/limiter.rst:10
#: ../../functions/video/median.rst:12
#: ../../functions/video/minimum_maximum.rst:11
#: ../../functions/video/minimum_maximum.rst:45
#: ../../functions/video/prewitt_sobel.rst:15
msgid ""
"Clip to process. It must have integer sample type and bit depth between 8 "
"and 16, or float sample type and bit depth of 32. If there are any frames "
"with other formats, an error will be returned."
msgstr "要处理的片段。必须具有 8 到 16 位之间的整数采样类型，或 32 位的浮点采样类型。如果存在其他格式的帧，将返回错误。"

#: ../../functions/video/binarize_binarizemask.rst:19
#: ../../functions/video/deflate_inflate.rst:20
#: ../../functions/video/deflate_inflate.rst:42
#: ../../functions/video/minimum_maximum.rst:20
#: ../../functions/video/minimum_maximum.rst:54
msgid "*threshold*"
msgstr "*threshold*"

#: ../../functions/video/binarize_binarizemask.rst:20
msgid ""
"Defaults to the middle point of range allowed by the format. Can be "
"specified for each plane individually."
msgstr "默认为格式允许范围的中点。可以为每个平面单独指定。"

#: ../../functions/video/binarize_binarizemask.rst:23
msgid "*v0*"
msgstr "*v0*"

#: ../../functions/video/binarize_binarizemask.rst:24
msgid ""
"Value given to pixels that are below *threshold*. Can be specified for each "
"plane individually. Defaults to the lower bound of the format."
msgstr "低于 *threshold* 的像素所赋的值。可以为每个平面单独指定。默认为格式的下界。"

#: ../../functions/video/binarize_binarizemask.rst:27
msgid "*v1*"
msgstr "*v1*"

#: ../../functions/video/binarize_binarizemask.rst:28
msgid ""
"Value given to pixels that are greater than or equal to *threshold*. "
"Defaults to the maximum value allowed by the format. Can be specified for "
"each plane individually. Defaults to the upper bound of the format."
msgstr "大于或等于 *threshold* 的像素所赋的值。默认为格式允许的最大值。可以为每个平面单独指定。默认为格式的上界。"

#: ../../functions/video/binarize_binarizemask.rst:32
#: ../../functions/video/convolution.rst:59
#: ../../functions/video/deflate_inflate.rst:16
#: ../../functions/video/deflate_inflate.rst:38
#: ../../functions/video/invert_invertmask.rst:19
#: ../../functions/video/levels.rst:37 ../../functions/video/limiter.rst:21
#: ../../functions/video/median.rst:17
#: ../../functions/video/minimum_maximum.rst:16
#: ../../functions/video/minimum_maximum.rst:50
#: ../../functions/video/prewitt_sobel.rst:20
msgid "*planes*"
msgstr "*planes*"

#: ../../functions/video/binarize_binarizemask.rst:33
#: ../../functions/video/convolution.rst:60
#: ../../functions/video/deflate_inflate.rst:17
#: ../../functions/video/deflate_inflate.rst:39
#: ../../functions/video/invert_invertmask.rst:20
#: ../../functions/video/levels.rst:38 ../../functions/video/limiter.rst:22
#: ../../functions/video/median.rst:18
#: ../../functions/video/minimum_maximum.rst:17
#: ../../functions/video/minimum_maximum.rst:51
#: ../../functions/video/prewitt_sobel.rst:21
msgid ""
"Specifies which planes will be processed. Any unprocessed planes will be "
"simply copied."
msgstr "指定要处理的平面。未处理的平面将被简单复制。"

#: ../../functions/video/blankclip.rst:2
msgid "BlankClip"
msgstr "BlankClip"

#: ../../functions/video/blankclip.rst:7
msgid ""
"Generates a new empty clip. This can be useful to have when editing video or"
" for testing. The default is a 640x480 RGB24 24fps 10 second long black "
"clip. Instead of specifying every property individually, BlankClip can also "
"copy the properties from *clip*. If both an argument such as *width*, and "
"*clip* are set, then *width* will take precedence."
msgstr ""
"生成一个新的空片段。这在编辑视频或测试时很有用。默认是一个 640x480 RGB24 24fps 10 秒长的黑色片段。BlankClip 也可以从 "
"*clip* 复制属性，而无需单独指定每个属性。如果同时设置了 *width* 等参数和 *clip*，则 *width* 优先。"

#: ../../functions/video/blankclip.rst:17
msgid ""
"If *varsize* is set, a clip with variable size will be returned. The frames "
"themselves will still have the size given by the width and height arguments."
msgstr "如果设置了 *varsize*，将返回可变大小的片段。帧本身仍将具有 width 和 height 参数指定的大小。"

#: ../../functions/video/blankclip.rst:20
msgid ""
"If *varformat* is set, a clip with variable format will be returned. The "
"frames themselves will have the format given by the format argument."
msgstr "如果设置了 *varformat*，将返回可变格式的片段。帧本身将具有 format 参数指定的格式。"

#: ../../functions/video/blankclip.rst:23
msgid "It is never an error to use BlankClip."
msgstr "使用 BlankClip 永远不会出错。"

#: ../../functions/video/boxblur.rst:2
msgid "BoxBlur"
msgstr "BoxBlur"

#: ../../functions/video/boxblur.rst:7
msgid ""
"Performs a box blur which is fast even for large radius values. Using "
"multiple *passes* can be used to fairly cheaply approximate a gaussian blur."
" A *radius* of 0 means no processing is performed."
msgstr ""
"执行方框模糊，即使对于较大的半径值也很快。使用多个 *passes* 可以较低成本地近似高斯模糊。*radius* 为 0 表示不进行处理。"

#: ../../functions/video/cliptoprop.rst:2
msgid "ClipToProp"
msgstr "ClipToProp"

#: ../../functions/video/cliptoprop.rst:7
msgid ""
"Stores each frame of *mclip* as a frame property named *prop* in *clip*. "
"This is primarily intended to attach mask/alpha clips to another clip so "
"that editing operations will apply to both. Unlike most other filters the "
"output length is derived from the second argument named *mclip*."
msgstr ""
"将 *mclip* 的每一帧作为名为 *prop* 的帧属性存储在 *clip* 中。这主要用于将蒙版/alpha "
"片段附加到另一个片段上，以便编辑操作同时应用于两者。与大多数其他滤镜不同，输出长度取决于名为 *mclip* 的第二个参数。"

#: ../../functions/video/cliptoprop.rst:12
msgid ""
"If the attached *mclip* does not represent the alpha channel, you should set"
" *prop* to something else."
msgstr "如果附加的 *mclip* 不代表 alpha 通道，你应该将 *prop* 设置为其他值。"

#: ../../functions/video/cliptoprop.rst:15
msgid "It is the inverse of PropToClip()."
msgstr "它是 PropToClip() 的逆操作。"

#: ../../functions/video/convolution.rst:2
msgid "Convolution"
msgstr "Convolution"

#: ../../functions/video/convolution.rst:7
msgid "Performs a spatial convolution."
msgstr "执行空间卷积。"

#: ../../functions/video/convolution.rst:9
msgid ""
"Here is how a 3x3 convolution is done. Each pixel in the 3x3 neighbourhood "
"is multiplied by the corresponding coefficient in *matrix*. The results of "
"the nine multiplications are added together, then this sum is divided by "
"*divisor*. Next, *bias* is added, and the result is rounded to the nearest "
"larger integer. If this integer result is negative and the *saturate* "
"parameter is False, it is multiplied by -1. Finally, the result is clamped "
"to the format's range of valid values."
msgstr ""
"以下是 3x3 卷积的工作原理。3x3 邻域中的每个像素乘以 *matrix* 中相应的系数。九次乘法的结果相加，然后除以 "
"*divisor*。接下来加上 *bias*，结果四舍五入到最接近的较大整数。如果此整数结果为负且 *saturate* 参数为 False，则乘以 "
"-1。最后，结果被钳制到格式的有效值范围内。"

#: ../../functions/video/convolution.rst:24
msgid "*matrix*"
msgstr "*matrix*"

#: ../../functions/video/convolution.rst:25
msgid "Coefficients for the convolution."
msgstr "卷积系数。"

#: ../../functions/video/convolution.rst:27
msgid ""
"When *mode* is \"s\", this must be an array of 9 or 25 numbers, for a 3x3 or"
" 5x5 convolution, respectively."
msgstr "当 *mode* 为 \"s\" 时，必须是 9 或 25 个数字的数组，分别对应 3x3 或 5x5 卷积。"

#: ../../functions/video/convolution.rst:30
msgid ""
"When *mode* is not \"s\", this must be an array of 3 to 25 numbers, with an "
"odd number of elements."
msgstr "当 *mode* 不为 \"s\" 时，必须是 3 到 25 个数字的数组，元素数为奇数。"

#: ../../functions/video/convolution.rst:33
msgid ""
"The values of the coefficients must be between -1023 and 1023 (inclusive). "
"The coefficients are rounded to integers when the input is an integer "
"format."
msgstr "系数值必须在 -1023 和 1023 之间（含）。当输入为整数格式时，系数将四舍五入为整数。"

#: ../../functions/video/convolution.rst:37
msgid ""
"This is how the elements of *matrix* correspond to the pixels in a 3x3 "
"neighbourhood::"
msgstr "以下是 *matrix* 元素与 3x3 邻域中像素的对应关系："

#: ../../functions/video/convolution.rst:44
msgid ""
"It's the same principle for the other types of convolutions. The middle "
"element of *matrix* always corresponds to the center pixel."
msgstr "其他类型的卷积也遵循相同的原理。*matrix* 的中间元素始终对应中心像素。"

#: ../../functions/video/convolution.rst:47
msgid "*bias*"
msgstr "*bias*"

#: ../../functions/video/convolution.rst:48
msgid ""
"Value to add to the final result of the convolution (before clamping the "
"result to the format's range of valid values)."
msgstr "添加到卷积最终结果的值（在将结果钳制到格式的有效值范围之前）。"

#: ../../functions/video/convolution.rst:51
msgid "*divisor*"
msgstr "*divisor*"

#: ../../functions/video/convolution.rst:52
msgid ""
"Divide the output of the convolution by this value (before adding *bias*)."
msgstr "将卷积输出除以此值（在添加 *bias* 之前）。"

#: ../../functions/video/convolution.rst:55
msgid ""
"If this parameter is 0.0 (the default), the output of the convolution will "
"be divided by the sum of the elements of *matrix*, or by 1.0, if the sum is "
"0."
msgstr "如果此参数为 0.0（默认值），卷积的输出将除以 *matrix* 元素之和，如果和为 0 则除以 1.0。"

#: ../../functions/video/convolution.rst:63
msgid "*saturate*"
msgstr "*saturate*"

#: ../../functions/video/convolution.rst:64
msgid ""
"The final result is clamped to the format's range of valid values (0 .. "
"(2**bitdepth)-1). Therefore, if this parameter is True, negative values "
"become 0. If this parameter is False, it's instead the absolute value that "
"is clamped and returned."
msgstr ""
"最终结果会被钳位到格式的有效值范围 (0 .. (2**bitdepth)-1)。因此，如果此参数为 True，负值会变为 0。如果此参数为 "
"False，则会对绝对值进行钳位并返回。"

#: ../../functions/video/convolution.rst:69
msgid "*mode*"
msgstr "*mode*"

#: ../../functions/video/convolution.rst:70
msgid ""
"Selects the type of convolution. Possible values are \"s\", for square, "
"\"h\" for horizontal, \"v\" for vertical, and \"hv\" or \"vh\" for both "
"horizontal and vertical."
msgstr "选择卷积类型。可能的值为 \"s\" 表示方形，\"h\" 表示水平，\"v\" 表示垂直，\"hv\" 或 \"vh\" 表示水平和垂直组合。"

#: ../../functions/video/convolution.rst:74
msgid "How to apply a simple blur equivalent to Avisynth's Blur(1):"
msgstr "如何应用等同于 Avisynth 的 Blur(1) 的简单模糊："

#: ../../functions/video/convolution.rst:80
msgid "How to apply a stronger blur equivalent to Avisynth's Blur(1.58):"
msgstr "如何应用等同于 Avisynth 的 Blur(1.58) 的更强模糊："

#: ../../functions/video/copyframeprops.rst:2
msgid "CopyFrameProps"
msgstr "CopyFrameProps"

#: ../../functions/video/copyframeprops.rst:7
msgid ""
"Returns *clip* but with all the frame properties replaced with the ones from"
" the clip in *prop_src*. Note that if *clip* is longer than *prop_src* then "
"the last source frame's properties will be used instead."
msgstr ""
"返回 *clip*，但所有帧属性替换为 *prop_src* 中对应剪辑的帧属性。注意，如果 *clip* 比 *prop_src* "
"长，则将使用源的最后一帧的属性。"

#: ../../functions/video/copyframeprops.rst:12
msgid ""
"If *props* is set only the specified properties will be copied. If the "
"*prop_src* doesn't have the property it is deleted. In this mode all other "
"properties in *clip* remain unchanged."
msgstr ""
"如果设置了 *props*，则只复制指定的属性。如果 *prop_src* 没有该属性，则该属性会被删除。在此模式下，*clip* "
"中的其他所有属性保持不变。"

#: ../../functions/video/crop_cropabs.rst:2
msgid "Crop/CropAbs"
msgstr "Crop/CropAbs"

#: ../../functions/video/crop_cropabs.rst:8
msgid "Crops the frames in a clip."
msgstr "裁剪片段中的帧。"

#: ../../functions/video/crop_cropabs.rst:10
msgid ""
"Crop is the simplest to use of the two. The arguments specify how many "
"pixels to crop from each side. This function used to be called CropRel which"
" is still an alias for it."
msgstr "Crop 是两者中最简单的。参数指定从每侧裁剪多少像素。此函数以前叫 CropRel，仍然是它的别名。"

#: ../../functions/video/crop_cropabs.rst:14
msgid ""
"CropAbs, on the other hand, is special, because it can accept clips with "
"variable frame sizes and crop out a fixed size area, thus making it a fixed "
"size clip."
msgstr "另一方面，CropAbs 比较特殊，因为它可以接受可变帧大小的片段并裁剪出固定大小的区域，从而使其成为固定大小的片段。"

#: ../../functions/video/crop_cropabs.rst:18
msgid ""
"Both functions return an error if the whole picture is cropped away, if the "
"cropped area extends beyond the input or if the subsampling restrictions "
"aren't met."
msgstr "如果整个画面被裁剪掉、裁剪区域超出输入范围或不满足子采样限制，两个函数都会返回错误。"

#: ../../functions/video/deflate_inflate.rst:2
msgid "Deflate/Inflate"
msgstr "Deflate/Inflate"

#: ../../functions/video/deflate_inflate.rst:7
msgid ""
"Replaces each pixel with the average of the eight pixels in its 3x3 "
"neighbourhood, but only if that average is less than the center pixel."
msgstr "将每个像素替换为其 3x3 邻域中八个像素的平均值，但仅当该平均值小于中心像素时。"

#: ../../functions/video/deflate_inflate.rst:21
#: ../../functions/video/minimum_maximum.rst:21
#: ../../functions/video/minimum_maximum.rst:55
msgid ""
"Allows to limit how much pixels are changed. Output pixels will not become "
"less than ``input - threshold``. The default is no limit."
msgstr "允许限制像素变化量。输出像素不会小于 ``input - threshold``。默认无限制。"

#: ../../functions/video/deflate_inflate.rst:28
msgid ""
"Replaces each pixel with the average of the eight pixels in its 3x3 "
"neighbourhood, but only if that average is greater than the center pixel."
msgstr "将每个像素替换为其 3x3 邻域中八个像素的平均值，但仅当该平均值大于中心像素时。"

#: ../../functions/video/deflate_inflate.rst:43
msgid ""
"Allows to limit how much pixels are changed. Output pixels will not become "
"greater than ``input + threshold``. The default is no limit."
msgstr "允许限制像素变化量。输出像素不会大于 ``input + threshold``。默认无限制。"

#: ../../functions/video/deleteframes.rst:2
msgid "DeleteFrames"
msgstr "DeleteFrames"

#: ../../functions/video/deleteframes.rst:7
msgid "Deletes the specified frames."
msgstr "删除指定的帧。"

#: ../../functions/video/deleteframes.rst:9
#: ../../functions/video/duplicateframes.rst:11
msgid "All frame numbers apply to the input clip."
msgstr "所有帧号适用于输入片段。"

#: ../../functions/video/deleteframes.rst:11
msgid ""
"Returns an error if the same frame is deleted twice or if all frames in a "
"clip are deleted."
msgstr "如果相同的帧被删除两次或片段中所有帧都被删除，将返回错误。"

#: ../../functions/video/doubleweave.rst:2
msgid "DoubleWeave"
msgstr "DoubleWeave"

#: ../../functions/video/doubleweave.rst:7
msgid "Weaves the fields back together from a clip with interleaved fields."
msgstr "将交错场的片段中的场重新编织在一起。"

#: ../../functions/video/doubleweave.rst:9
msgid ""
"Since VapourSynth only has a weak notion of field order internally, *tff* "
"may have to be set. Setting *tff* to true means top fields first and false "
"means bottom fields first. Note that the ``_Field`` frame property, if "
"present and in a valid combination, takes precedence over *tff*."
msgstr ""
"由于 VapourSynth 内部对场序仅有弱概念，可能需要设置 *tff*。将 *tff* 设置为 true 表示顶场优先，false "
"表示底场优先。注意，如果存在 ``_Field`` 帧属性且组合有效，则其优先于 *tff*。"

#: ../../functions/video/doubleweave.rst:14
msgid ""
"DoubleWeave's output has the same number of frames as the input. One must "
"use DoubleWeave together with SelectEvery to undo the effect of "
"SeparateFields::"
msgstr ""
"DoubleWeave 的输出帧数与输入相同。必须将 DoubleWeave 与 SelectEvery 一起使用才能撤消 SeparateFields"
" 的效果::"

#: ../../functions/video/doubleweave.rst:23
msgid ""
"The ``_Field`` frame property is deleted and ``_FieldBased`` is set "
"accordingly."
msgstr "``_Field`` 帧属性被删除，``_FieldBased`` 相应设置。"

#: ../../functions/video/duplicateframes.rst:2
msgid "DuplicateFrames"
msgstr "DuplicateFrames"

#: ../../functions/video/duplicateframes.rst:7
msgid "Duplicates the specified frames."
msgstr "复制指定的帧。"

#: ../../functions/video/duplicateframes.rst:9
msgid "A frame may be duplicated several times."
msgstr "一帧可以被复制多次。"

#: ../../functions/video/expr.rst:2
msgid "Expr"
msgstr "Expr"

#: ../../functions/video/expr.rst:7
msgid ""
"Expr evaluates an expression per pixel for up to 26 input *clips*. The "
"expression, *expr*, is written using reverse polish notation and can be "
"specified for each plane individually. The expression given for the previous"
" plane is used if the *expr* array contains fewer expressions than the input"
" clip has planes. In practice this means that a single expression will be "
"applied to all planes by default."
msgstr ""
"Expr 对最多 26 个输入 *clips* 逐像素计算表达式。表达式 *expr* 使用逆波兰表示法编写，可以为每个平面单独指定。如果 *expr*"
" 数组包含的表达式少于输入剪辑的平面数，则使用前一个平面给出的表达式。实际上这意味着默认情况下单个表达式将应用于所有平面。"

#: ../../functions/video/expr.rst:15
msgid ""
"Specifying an empty string as the expression enables a fast plane copy from "
"the first specified clip, when possible. If it is not possible due to the "
"output *format* being incompatible, the plane contents will be undefined."
msgstr ""
"指定空字符串作为表达式可以在可能的情况下从第一个指定片段快速复制平面。如果由于输出 *format* 不兼容而不可能，平面内容将是未定义的。"

#: ../../functions/video/expr.rst:19
msgid ""
"Since the expression is evaluated at runtime, there are a few pitfalls. In "
"order to keep speed up, the input ranges are not normalized to the usual "
"floating point ranges. Instead they are left as is, meaning that an 8 bit "
"clip will have values in the 0-255 range and a 10 bit clip will have values "
"in the 0-1023 range. Note that floating point clips are even more difficult,"
" as most channels are stored in the 0-1 range with the exception of U, V, Co"
" and Cg planes, which are in the -0.5-0.5 range. If you mix clips with "
"different input formats this must be taken into consideration."
msgstr ""
"由于表达式在运行时求值，因此有一些注意事项。为了保持速度，输入范围不会归一化到通常的浮点范围，而是保持原样，这意味着 8 位剪辑的值在 0-255 "
"范围内，10 位剪辑的值在 0-1023 范围内。注意浮点剪辑更加复杂，大多数通道存储在 0-1 范围内，但 U、V、Co 和 Cg 平面例外，它们在 "
"-0.5-0.5 范围内。如果混合不同输入格式的剪辑，必须考虑这一点。"

#: ../../functions/video/expr.rst:30
msgid ""
"When the output format uses integer samples, the result of the expression is"
" clamped to the [0, 2**bits_per_sample-1] range. When the output format uses"
" float samples, the result of the expression is stored without any clamping."
msgstr ""
"当输出格式使用整数采样时，表达式的结果会被钳位到 [0, 2**bits_per_sample-1] "
"范围。当输出格式使用浮点采样时，表达式的结果不经任何钳位直接存储。"

#: ../../functions/video/expr.rst:35
msgid ""
"By default the output *format* is the same as the first input clip's format."
" You can override it by setting *format*. The only restriction is that the "
"output *format* must have the same subsampling as the input *clips* and be "
"8..16 bit integer or 32 bit float. 16 bit float is also supported on cpus "
"with the f16c instructions."
msgstr ""
"默认情况下，输出 *format* 与第一个输入剪辑的格式相同。你可以通过设置 *format* 来覆盖它。唯一的限制是输出 *format* "
"必须与输入 *clips* 具有相同的子采样，并且是 8..16 位整数或 32 位浮点。在支持 f16c 指令的 CPU 上也支持 16 位浮点。"

#: ../../functions/video/expr.rst:41
msgid ""
"Logical operators are also a bit special, since everything is done in "
"floating point arithmetic. All values greater than 0 are considered true for"
" the purpose of comparisons. Logical operators return 0.0 for false and 1.0 "
"for true in their operations."
msgstr ""
"逻辑运算符也有些特殊，因为所有运算都是以浮点算术完成的。所有大于 0 的值在比较时被视为 true。逻辑运算符在运算中返回 0.0 表示 "
"false，1.0 表示 true。"

#: ../../functions/video/expr.rst:46
msgid ""
"Since the expression is being evaluated at runtime, there are also the stack"
" manipulation operators, *swap* and *dup*. The former swaps the topmost and "
"second topmost values, and the latter duplicates the topmost stack value."
msgstr "由于表达式在运行时求值，还有栈操作运算符 *swap* 和 *dup*。前者交换栈顶和第二个栈顶值，后者复制栈顶值。"

#: ../../functions/video/expr.rst:50
msgid ""
"These operators also have *swapN* and *dupN* forms that allow a value N "
"steps up in the stack to be swapped or duplicated. The top value of the "
"stack has index zero meaning that *dup* is equivalent to *dup0* and *swap* "
"is equivalent to *swap1*. This is because *swapN* always swaps with the "
"topmost value at index 0."
msgstr ""
"这些运算符还有 *swapN* 和 *dupN* 形式，允许交换或复制栈中向上 N 步的值。栈顶值的索引为零，这意味着 *dup* 等同于 "
"*dup0*，*swap* 等同于 *swap1*。这是因为 *swapN* 始终与索引 0 处的栈顶值交换。"

#: ../../functions/video/expr.rst:56
msgid ""
"Expressions are converted to byte-code or machine-code by an optimizing "
"compiler and are not guaranteed to evaluate in the order originally written."
" The compiler assumes that all input values are finite (i.e neither NaN nor "
"INF) and that no operator will produce a non-finite value. Such expressions "
"are invalid. This is especially important for the transcendental operators:"
msgstr ""
"表达式由优化编译器转换为字节码或机器码，不保证按原始编写顺序求值。编译器假设所有输入值都是有限的（即既不是 NaN 也不是 "
"INF），并且没有运算符会产生非有限值。这样的表达式是无效的。这对超越函数运算符尤其重要："

#: ../../functions/video/expr.rst:62
msgid "exp - expression must not overflow (i.e. x <= 88)"
msgstr "exp - 表达式不能溢出（即 x <= 88）"

#: ../../functions/video/expr.rst:63
msgid ""
"log - input must be finite and non-negative (i.e. x >= 0 && x <= 3e+38)"
msgstr "log - 输入必须是有限且非负的（即 x >= 0 && x <= 3e+38）"

#: ../../functions/video/expr.rst:64
msgid ""
"pow - base must be finite and non-negative. Result must not overflow (i.e. x"
" >= 0 && x <= 3e+38; 1e-38 <= result <= 3e+38)"
msgstr ""
"pow - 底数必须是有限且非负的。结果不能溢出（即 x >= 0 && x <= 3e+38；1e-38 <= result <= 3e+38）"

#: ../../functions/video/expr.rst:66
msgid "Clip load operators::"
msgstr "片段加载运算符："

#: ../../functions/video/expr.rst:70
msgid "The operators taking one argument are::"
msgstr "接受一个参数的运算符："

#: ../../functions/video/expr.rst:74
msgid "The operators taking two arguments are::"
msgstr "接受两个参数的运算符："

#: ../../functions/video/expr.rst:78
msgid "The operators taking three arguments are::"
msgstr "接受三个参数的运算符："

#: ../../functions/video/expr.rst:82
msgid "For example these operations::"
msgstr "例如以下操作："

#: ../../functions/video/expr.rst:90
msgid "Are equivalent to these operations in C::"
msgstr "等价于 C 中的这些操作："

#: ../../functions/video/expr.rst:98
msgid ""
"The sin/cos operators are approximated to within 2e-6 absolute error for "
"inputs with magnitude up to 1e5, and there is no accuracy guarantees for "
"inputs whose magnitude is larger than 2e5."
msgstr "sin/cos 运算符对于幅度不超过 1e5 的输入近似到 2e-6 绝对误差以内，对于幅度大于 2e5 的输入没有精度保证。"

#: ../../functions/video/expr.rst:102
msgid ""
"How to average the Y planes of 3 YUV clips and pass through the UV planes "
"unchanged (assuming same format)::"
msgstr "如何平均 3 个 YUV 片段的 Y 平面并保持 UV 平面不变（假设相同格式）："

#: ../../functions/video/expr.rst:107
msgid ""
"How to average the Y planes of 3 YUV clips and pass through the UV planes "
"unchanged (different formats)::"
msgstr "如何平均 3 个 YUV 片段的 Y 平面并保持 UV 平面不变（不同格式）："

#: ../../functions/video/expr.rst:113
msgid ""
"Setting the output format because the resulting values are illegal in a 10 "
"bit clip (note that the U and V planes will contain junk since direct copy "
"isn't possible)::"
msgstr "设置输出格式，因为结果值在 10 位剪辑中不合法（注意 U 和 V 平面将包含垃圾数据，因为无法直接复制）::"

#: ../../functions/video/flipvertical_fliphorizontal.rst:2
msgid "FlipVertical/FlipHorizontal"
msgstr "FlipVertical/FlipHorizontal"

#: ../../functions/video/flipvertical_fliphorizontal.rst:8
msgid "Flips the *clip* in the vertical or horizontal direction."
msgstr "在垂直或水平方向翻转 *clip*。"

#: ../../functions/video/frameeval.rst:2
msgid "FrameEval"
msgstr "FrameEval"

#: ../../functions/video/frameeval.rst:7
msgid ""
"Allows an arbitrary function to be evaluated every frame. The function gets "
"the frame number, *n*, as input and should return a clip the output frame "
"can be requested from."
msgstr "允许在每帧评估任意函数。函数获取帧号 *n* 作为输入，应返回一个可以请求输出帧的片段。"

#: ../../functions/video/frameeval.rst:11
msgid ""
"The *clip* argument is only used to get the output format from since there "
"is no reliable automatic way to deduce it."
msgstr "*clip* 参数仅用于获取输出格式，因为没有可靠的自动推断方式。"

#: ../../functions/video/frameeval.rst:14
msgid ""
"When using the argument *prop_src* the function will also have an argument, "
"*f*, containing the current frames. This is mainly so frame properties can "
"be accessed and used to make decisions. Note that *f* will only be a list if"
" more than one *prop_src* clip is provided."
msgstr ""
"使用参数 *prop_src* 时，函数还会有一个参数 *f*，包含当前帧。这主要是为了可以访问帧属性并用于决策。注意只有提供了多个 "
"*prop_src* 剪辑时，*f* 才会是一个列表。"

#: ../../functions/video/frameeval.rst:19
msgid ""
"The *clip_src* argument only exists as a way to hint which clips are "
"referenced in the *eval* function which can improve caching and graph "
"generation. Its use is encouraged but not required."
msgstr "*clip_src* 参数仅用于提示 *eval* 函数中引用了哪些剪辑，这可以改善缓存和图生成。鼓励使用但不是必需的。"

#: ../../functions/video/frameeval.rst:23
msgid ""
"This function can be used to accomplish the same things as Animate, "
"ScriptClip and all the other conditional filters in Avisynth. Note that to "
"modify per frame properties you should use *ModifyFrame*."
msgstr ""
"此函数可用于完成 Avisynth 中的 Animate、ScriptClip 和所有其他条件滤镜能做的事情。请注意，要修改逐帧属性，应使用 "
"*ModifyFrame*。"

#: ../../functions/video/frameeval.rst:27
msgid ""
"How to animate a BlankClip to fade from white to black. This is the simplest"
" use case without using the *prop_src* argument::"
msgstr "如何使 BlankClip 动画从白色淡出到黑色。这是不使用 *prop_src* 参数的最简单用例："

#: ../../functions/video/frameeval.rst:44
msgid ""
"How to perform a simple per frame auto white balance. It shows how to access"
" calculated frame properties and use them for conditional filtering::"
msgstr "如何执行简单的逐帧自动白平衡。展示了如何访问计算的帧属性并使用它们进行条件滤波："

#: ../../functions/video/freezeframes.rst:2
msgid "FreezeFrames"
msgstr "FreezeFrames"

#: ../../functions/video/freezeframes.rst:7
msgid ""
"FreezeFrames replaces all the frames in the [*first*,\\ *last*] range "
"(inclusive) with *replacement*."
msgstr "FreezeFrames 将 [*first*,\\ *last*] 范围（含）内的所有帧替换为 *replacement*。"

#: ../../functions/video/freezeframes.rst:10
msgid "A single call to FreezeFrames can freeze any number of ranges::"
msgstr "一次 FreezeFrames 调用可以冻结任意数量的范围："

#: ../../functions/video/freezeframes.rst:14
msgid ""
"This replaces [0,15] with 8, [100,112] with 50, and [231,300] with 2 (the "
"original frame number 2, not frame number 2 after it was replaced with "
"number 8 by the first range)."
msgstr ""
"这将 [0,15] 替换为第 8 帧，[100,112] 替换为第 50 帧，[231,300] 替换为第 2 帧（原始第 2 "
"帧，不是第一个范围替换后的第 2 帧）。"

#: ../../functions/video/freezeframes.rst:18
msgid "The frame ranges must not overlap."
msgstr "帧范围不得重叠。"

#: ../../functions/video/interleave.rst:2
msgid "Interleave"
msgstr "Interleave"

#: ../../functions/video/interleave.rst:7
msgid ""
"Returns a clip with the frames from all *clips* interleaved. For example, "
"Interleave(clips=[A, B]) will return A.Frame 0, B.Frame 0, A.Frame 1, "
"B.Frame..."
msgstr ""
"返回一个帧来自所有 *clips* 交错排列的剪辑。例如，Interleave(clips=[A, B]) 将返回 A.帧 0、B.帧 0、A.帧 "
"1、B.帧..."

#: ../../functions/video/interleave.rst:11
msgid ""
"The *extend* argument controls whether or not all input clips will be "
"treated as if they have the same length as the longest clip."
msgstr "*extend* 参数控制是否将所有输入片段视为与最长片段具有相同的长度。"

#: ../../functions/video/interleave.rst:14
msgid ""
"Interleaving clips with different formats or dimensions is considered an "
"error unless *mismatch* is true."
msgstr "交错不同格式或维度的片段将被视为错误，除非 *mismatch* 为 true。"

#: ../../functions/video/interleave.rst:17
msgid ""
"If *modify_duration* is set then the output clip's frame rate is the first "
"input clip's frame rate multiplied by the number of input clips. The frame "
"durations are divided by the number of input clips. Otherwise the first "
"input clip's frame rate is used."
msgstr ""
"如果设置了 "
"*modify_duration*，则输出剪辑的帧率为第一个输入剪辑的帧率乘以输入剪辑数量。帧时长除以输入剪辑数量。否则使用第一个输入剪辑的帧率。"

#: ../../functions/video/invert_invertmask.rst:2
msgid "Invert/InvertMask"
msgstr "Invert/InvertMask"

#: ../../functions/video/invert_invertmask.rst:8
msgid ""
"Inverts the pixel values. Specifically, it subtracts the value of the input "
"pixel from the format's maximum allowed value. The *InvertMask* version is "
"intended for use on mask clips where all planes have the same maximum value "
"regardless of the colorspace."
msgstr ""
"反转像素值。具体来说，它用格式的最大允许值减去输入像素的值。*InvertMask* "
"版本旨在用于蒙版剪辑，其中所有平面具有相同的最大值，不受色彩空间影响。"

#: ../../functions/video/levels.rst:2
msgid "Levels"
msgstr "Levels"

#: ../../functions/video/levels.rst:7
msgid "Adjusts brightness, contrast, and gamma."
msgstr "调整亮度、对比度和伽马值。"

#: ../../functions/video/levels.rst:9
msgid ""
"The range [*min_in*, *max_in*] is remapped into [*min_out*, *max_out*]. Note"
" that the range behavior is unintuitive for YUV float formats since the "
"assumed range will be 0-1 even for the UV-planes."
msgstr ""
"范围 [*min_in*, *max_in*] 被重新映射到 [*min_out*, *max_out*]。注意对于 YUV "
"浮点格式，范围行为不太直观，因为即使对于 UV 平面，假定范围也是 0-1。"

#: ../../functions/video/levels.rst:13
msgid "For example, to convert from limited range YUV to full range (8 bit)::"
msgstr "例如，将有限范围 YUV 转换为全范围（8 位）："

#: ../../functions/video/levels.rst:18
msgid ""
"The default value of *max_in* and *max_out* is the format's minimum and "
"maximum allowed values respectively. Note that all input is clamped to the "
"input range to prevent out of range output."
msgstr "*max_in* 和 *max_out* 的默认值分别是格式的最小和最大允许值。注意所有输入都会被钳位到输入范围，以防止超出范围的输出。"

#: ../../functions/video/levels.rst:23
msgid ""
"The default ranges are 0-1 for floating point formats. This may have an "
"undesired"
msgstr "浮点格式的默认范围为 0-1。这可能会对"

#: ../../functions/video/levels.rst:24
msgid "effect on YUV formats."
msgstr "YUV 格式产生不期望的效果。"

#: ../../functions/video/levels.rst:32
msgid "*gamma*"
msgstr "*gamma*"

#: ../../functions/video/levels.rst:33
msgid ""
"Controls the degree of non-linearity of the conversion. Values greater than "
"1.0 brighten the output, while values less than 1.0 darken it."
msgstr "控制转换的非线性程度。大于 1.0 的值使输出变亮，小于 1.0 的值使其变暗。"

#: ../../functions/video/limiter.rst:2
msgid "Limiter"
msgstr "Limiter"

#: ../../functions/video/limiter.rst:7
msgid "Limits the pixel values to the range [*min*, *max*]."
msgstr "将像素值限制在 [*min*, *max*] 范围内。"

#: ../../functions/video/limiter.rst:15
msgid "*min*"
msgstr "*min*"

#: ../../functions/video/limiter.rst:16
msgid ""
"Lower bound. Defaults to the lowest allowed value for the input. Can be "
"specified for each plane individually."
msgstr "下界。默认为输入允许的最低值。可以为每个平面单独指定。"

#: ../../functions/video/limiter.rst:18
msgid "*max*"
msgstr "*max*"

#: ../../functions/video/limiter.rst:19
msgid ""
"Upper bound. Defaults to the highest allowed value for the input. Can be "
"specified for each plane individually."
msgstr "上界。默认为输入允许的最高值。可以为每个平面单独指定。"

#: ../../functions/video/loop.rst:2
msgid "Loop"
msgstr "Loop"

#: ../../functions/video/loop.rst:11
msgid ""
"In Python, std.Loop can also be invoked :ref:`using the multiplication "
"operator <pythonreference>`."
msgstr "在 Python 中，std.Loop 也可以通过 :ref:`乘法运算符 <pythonreference>` 调用。"

#: ../../functions/video/lut.rst:2
msgid "Lut"
msgstr "Lut"

#: ../../functions/video/lut.rst:7
msgid ""
"Applies a look-up table to the given clip. The lut can be specified as "
"either an array of 2^bits_per_sample values or given as a *function* having "
"an argument named *x* to be evaluated. Either *lut*, *lutf* or *function* "
"must be used. The lut will be applied to the planes listed in *planes* and "
"the other planes will simply be passed through unchanged. By default all "
"*planes* are processed."
msgstr ""
"对给定剪辑应用查找表。查找表可以指定为 2^bits_per_sample 个值的数组，或者作为具有名为 *x* 的参数的 *function* "
"来求值。必须使用 *lut*、*lutf* 或 *function* 之一。查找表将应用于 *planes* "
"中列出的平面，其他平面将简单地不改变地传递。默认情况下处理所有 *planes*。"

#: ../../functions/video/lut.rst:13 ../../functions/video/lut2.rst:20
msgid ""
"If *floatout* is set then the output will be floating point instead, and "
"either *lutf* needs to be set or *function* always needs to return floating "
"point values."
msgstr "如果设置了 *floatout*，则输出将是浮点格式，并且需要设置 *lutf* 或 *function* 始终需要返回浮点值。"

#: ../../functions/video/lut.rst:17
msgid "How to limit YUV range (by passing an array):"
msgstr "如何限制 YUV 范围（通过传递数组）："

#: ../../functions/video/lut.rst:30
msgid "How to limit YUV range (using a function):"
msgstr "如何限制 YUV 范围（使用函数）："

#: ../../functions/video/lut2.rst:2
msgid "Lut2"
msgstr "Lut2"

#: ../../functions/video/lut2.rst:7
msgid ""
"Applies a look-up table that takes into account the pixel values of two "
"clips. The *lut* needs to contain 2^(clip1.bits_per_sample + "
"clip2.bits_per_sample) entries and will be applied to the planes listed in "
"*planes*. Alternatively a *function* taking *x* and *y* as arguments can be "
"used to make the lut. The other planes will be passed through unchanged. By "
"default all *planes* are processed."
msgstr ""
"应用一个考虑两个剪辑像素值的查找表。*lut* 需要包含 2^(clip1.bits_per_sample + "
"clip2.bits_per_sample) 个条目，并将应用于 *planes* 中列出的平面。也可以使用接受 *x* 和 *y* 作为参数的 "
"*function* 来创建查找表。其他平面将不改变地传递。默认情况下处理所有 *planes*。"

#: ../../functions/video/lut2.rst:14
msgid ""
"Lut2 also takes an optional bit depth parameter, *bits*, which defaults to "
"the bit depth of the first input clip, and specifies the bit depth of the "
"output clip. The user is responsible for understanding the effects of bit "
"depth conversion, specifically from higher bit depths to lower bit depths, "
"as no scaling or clamping is applied."
msgstr ""
"Lut2 还接受一个可选的位深参数 "
"*bits*，默认为第一个输入剪辑的位深，用于指定输出剪辑的位深。用户需要自行理解位深转换的影响，特别是从高位深到低位深的转换，因为不会应用缩放或钳位。"

#: ../../functions/video/lut2.rst:24
msgid "How to average 2 clips:"
msgstr "如何平均 2 个片段："

#: ../../functions/video/lut2.rst:34
msgid "How to average 2 clips with a 10-bit output:"
msgstr "如何使用 10 位输出平均 2 个片段："

#: ../../functions/video/makediff.rst:2
msgid "MakeDiff"
msgstr "MakeDiff"

#: ../../functions/video/makediff.rst:7
msgid ""
"Calculates the difference between *clipa* and *clipb* and clamps the result."
" By default all *planes* are processed. This function is usually used "
"together with *MergeDiff*, which can be used to add back the difference."
msgstr ""
"计算 *clipa* 和 *clipb* 之间的差异并钳位结果。默认情况下处理所有 *planes*。此函数通常与 *MergeDiff* "
"一起使用，后者可用于将差异加回。"

#: ../../functions/video/makediff.rst:10
#: ../../functions/video/mergediff.rst:10
msgid "Unsharp masking of luma::"
msgstr "亮度反锐化蒙版："

#: ../../functions/video/makefulldiff.rst:2
msgid "MakeFullDiff"
msgstr "MakeFullDiff"

#: ../../functions/video/makefulldiff.rst:7
msgid ""
"Calculates the difference between *clipa* and *clipb* and outputs a clip "
"with a one higher bitdepth to avoid the clamping or wraparound issues that "
"would otherwise happen with filters like *MakeDiff* when forming a "
"difference. This function is usually used together with *MergeFullDiff*, "
"which can be used to add back the difference."
msgstr ""
"计算 *clipa* 和 *clipb* 之间的差异，并输出一个位深高一级的剪辑，以避免使用 *MakeDiff* "
"等滤镜形成差异时会出现的钳位或环绕问题。此函数通常与 *MergeFullDiff* 一起使用，后者可用于将差异加回。"

#: ../../functions/video/makefulldiff.rst:11
#: ../../functions/video/mergefulldiff.rst:10
msgid "Unsharp mask::"
msgstr "反锐化蒙版："

#: ../../functions/video/maskedmerge.rst:2
msgid "MaskedMerge"
msgstr "MaskedMerge"

#: ../../functions/video/maskedmerge.rst:7
msgid ""
"MaskedMerge merges *clipa* with *clipb* using the per pixel weights in the "
"*mask*, where 0 means that *clipa* is returned unchanged. The *mask* clip is"
" assumed to  be full range for all planes and in the 0-1 interval for float "
"formats regardless of the colorspace. If *mask* is a grayscale clip or if "
"*first_plane* is true, the mask's first plane will be used as the mask for "
"merging all planes. The mask will be bilinearly resized if necessary."
msgstr ""
"MaskedMerge 使用 *mask* 中的逐像素权重将 *clipa* 与 *clipb* 合并，其中 0 表示 *clipa* "
"不变地返回。*mask* 剪辑假定所有平面为满范围，对于浮点格式在 0-1 区间内，不受色彩空间影响。如果 *mask* 是灰度剪辑或 "
"*first_plane* 为 true，则蒙版的第一个平面将用作合并所有平面的蒙版。如果需要，蒙版将进行双线性缩放。"

#: ../../functions/video/maskedmerge.rst:15
msgid ""
"If *premultiplied* is set the blending is performed as if *clipb* has been "
"pre-multiplied with alpha. In pre-multiplied mode it is an error to try to "
"merge two frames with mismatched full and limited range since it will most "
"likely cause horrible unintended color shifts. In the other mode it's just a"
" very, very bad idea."
msgstr ""
"如果设置了 *premultiplied*，则混合操作将视为 *clipb* 已经与 alpha "
"预乘。在预乘模式下，尝试合并两个全范围和有限范围不匹配的帧会产生错误，因为这很可能导致严重的意外色彩偏移。在其他模式下，这也是一个非常非常糟糕的做法。"

#: ../../functions/video/maskedmerge.rst:20
msgid ""
"By default all planes will be processed, but it is also possible to specify "
"a list of the *planes* to merge in the output. The unprocessed planes will "
"be copied from the first clip."
msgstr "默认情况下所有平面都将被处理，但也可以指定要在输出中合并的 *planes* 列表。未处理的平面将从第一个剪辑复制。"

#: ../../functions/video/maskedmerge.rst:24
msgid ""
"*clipa* and *clipb* must have the same dimensions and format, and the *mask*"
" must be the same format as the clips or the grayscale equivalent."
msgstr "*clipa* 和 *clipb* 必须具有相同的尺寸和格式，*mask* 必须与片段相同格式或灰度等价格式。"

#: ../../functions/video/maskedmerge.rst:27
msgid "How to apply a mask to the first plane::"
msgstr "如何将蒙版应用于第一个平面："

#: ../../functions/video/maskedmerge.rst:31
msgid "How to apply the first plane of a mask to the second and third plane::"
msgstr "如何将蒙版的第一个平面应用于第二和第三个平面："

#: ../../functions/video/maskedmerge.rst:35 ../../functions/video/merge.rst:29
msgid "The frame properties are copied from *clipa*."
msgstr "帧属性从 *clipa* 复制。"

#: ../../functions/video/median.rst:2
msgid "Median"
msgstr "Median"

#: ../../functions/video/median.rst:7
msgid ""
"Replaces each pixel with the median of the nine pixels in its 3x3 "
"neighbourhood. In other words, the nine pixels are sorted from lowest to "
"highest, and the middle value is picked."
msgstr "将每个像素替换为其 3x3 邻域中九个像素的中值。换句话说，九个像素从低到高排序，选取中间值。"

#: ../../functions/video/merge.rst:2
msgid "Merge"
msgstr "Merge"

#: ../../functions/video/merge.rst:7
msgid ""
"Merges *clipa* and *clipb* using the specified *weight* for each plane. The "
"default is to use a 0.5 *weight* for all planes. A zero *weight* means that "
"*clipa* is returned unchanged and 1 means that *clipb* is returned "
"unchanged. If a single *weight* is specified, it will be used for all "
"planes. If two weights are given then the second value will be used for the "
"third plane as well."
msgstr ""
"使用指定的每个平面的 *weight* 合并 *clipa* 和 *clipb*。默认对所有平面使用 0.5 *weight*。*weight* "
"为零表示 *clipa* 不变返回，为 1 表示 *clipb* 不变返回。如果指定了单个 "
"*weight*，它将用于所有平面。如果给出两个权重，则第二个值也将用于第三个平面。"

#: ../../functions/video/merge.rst:13
msgid ""
"Values outside the 0-1 range are considered to be an error. Specifying more "
"weights than planes in the clips is also an error. The clips must have the "
"same dimensions and format."
msgstr "0-1 范围之外的值被视为错误。指定的权重数量多于剪辑中的平面数量也是错误的。剪辑必须具有相同的尺寸和格式。"

#: ../../functions/video/merge.rst:17
msgid "How to merge luma::"
msgstr "如何合并亮度："

#: ../../functions/video/merge.rst:21
msgid "How to merge chroma::"
msgstr "如何合并色度："

#: ../../functions/video/merge.rst:25
msgid "The average of two clips::"
msgstr "两个片段的平均值："

#: ../../functions/video/mergediff.rst:2
msgid "MergeDiff"
msgstr "MergeDiff"

#: ../../functions/video/mergediff.rst:7
msgid ""
"Merges back the difference in *clipb* to *clipa* and clamps the result. By "
"default all *planes* are processed. This function is usually used together "
"with *MakeDiff*, which is normally used to calculate the difference."
msgstr ""
"将 *clipb* 中的差异合并回 *clipa* 并钳位结果。默认情况下处理所有 *planes*。此函数通常与 *MakeDiff* "
"一起使用，后者通常用于计算差异。"

#: ../../functions/video/mergefulldiff.rst:2
msgid "MergeFullDiff"
msgstr "MergeFullDiff"

#: ../../functions/video/mergefulldiff.rst:7
msgid ""
"Merges back the difference in *clipb* to *clipa*. Note that the bitdepth of "
"*clipb* has to be one higher than that of *clip*. This function is usually "
"used together with *MakeFullDiff*, which is normally used to calculate the "
"difference."
msgstr ""
"将 *clipb* 中的差异合并回 *clipa*。注意 *clipb* 的位深必须比 *clip* 高一级。此函数通常与 *MakeFullDiff*"
" 一起使用，后者通常用于计算差异。"

#: ../../functions/video/minimum_maximum.rst:2
msgid "Minimum/Maximum"
msgstr "Minimum/Maximum"

#: ../../functions/video/minimum_maximum.rst:7
msgid ""
"Replaces each pixel with the smallest value in its 3x3 neighbourhood. This "
"operation is also known as erosion."
msgstr "将每个像素替换为其 3x3 邻域中的最小值。此操作也称为腐蚀。"

#: ../../functions/video/minimum_maximum.rst:24
#: ../../functions/video/minimum_maximum.rst:58
msgid "*coordinates*"
msgstr "*coordinates*"

#: ../../functions/video/minimum_maximum.rst:25
msgid ""
"Specifies which pixels from the 3x3 neighbourhood are considered. If an "
"element of this array is 0, the corresponding pixel is not considered when "
"finding the minimum value. This must contain exactly 8 numbers."
msgstr "指定考虑 3x3 邻域中的哪些像素。如果此数组的元素为 0，则在查找最小值时不考虑相应的像素。此数组必须恰好包含 8 个数字。"

#: ../../functions/video/minimum_maximum.rst:30
#: ../../functions/video/minimum_maximum.rst:64
msgid ""
"Here is how each number corresponds to a pixel in the 3x3 neighbourhood::"
msgstr "以下是每个数字与 3x3 邻域中像素的对应关系："

#: ../../functions/video/minimum_maximum.rst:41
msgid ""
"Replaces each pixel with the largest value in its 3x3 neighbourhood. This "
"operation is also known as dilation."
msgstr "将每个像素替换为其 3x3 邻域中的最大值。此操作也称为膨胀。"

#: ../../functions/video/minimum_maximum.rst:59
msgid ""
"Specifies which pixels from the 3x3 neighbourhood are considered. If an "
"element of this array is 0, the corresponding pixel is not considered when "
"finding the maximum value. This must contain exactly 8 numbers."
msgstr "指定考虑 3x3 邻域中的哪些像素。如果此数组的元素为 0，则在查找最大值时不考虑相应的像素。此数组必须恰好包含 8 个数字。"

#: ../../functions/video/modifyframe.rst:2
msgid "ModifyFrame"
msgstr "ModifyFrame"

#: ../../functions/video/modifyframe.rst:7
msgid ""
"The *selector* function is called for every single frame and can modify the "
"properties of one of the frames gotten from *clips*. The additional *clips*'"
" properties should only be read and not modified because only one modified "
"frame can be returned."
msgstr ""
"*selector* 函数对每一帧调用，可以修改从 *clips* 获取的某一帧的属性。额外 *clips* "
"的属性应该只读不修改，因为只能返回一个修改后的帧。"

#: ../../functions/video/modifyframe.rst:12
msgid ""
"You must first copy the input frame to make it modifiable. Any frame may be "
"returned as long as it has the same format as the *clip*. Failure to do so "
"will produce an error. If for conditional reasons you do not need to modify "
"the current frame's properties, you can simply pass it through. The selector"
" function is passed *n*, the current frame number, and *f*, which is a frame"
" or a list of frames if there is more than one clip specified."
msgstr ""
"你必须先复制输入帧才能使其可修改。只要帧具有相同的格式，任何帧都可以返回。否则将产生错误。如果出于条件原因不需要修改当前帧的属性，可以直接传递。选择器函数接收"
" *n*（当前帧号）和 *f*（如果指定了多个剪辑，则为帧或帧列表）。"

#: ../../functions/video/modifyframe.rst:19
msgid ""
"If you do not need to modify frame properties but only read them, you should"
" probably be using *FrameEval* instead."
msgstr "如果你不需要修改帧属性而只是读取它们，你可能应该使用 *FrameEval* 代替。"

#: ../../functions/video/modifyframe.rst:22
msgid "How to set the property FrameNumber to the current frame number::"
msgstr "如何将属性 FrameNumber 设置为当前帧号："

#: ../../functions/video/modifyframe.rst:31
msgid "How to remove a property::"
msgstr "如何删除属性："

#: ../../functions/video/modifyframe.rst:40
msgid ""
"An example of how to copy certain properties from one clip to another (clip1"
" and clip2 have the same format)::"
msgstr "如何将某些属性从一个片段复制到另一个片段的示例（clip1 和 clip2 具有相同格式）："

#: ../../functions/video/pemverifier.rst:2
msgid "PEMVerifier"
msgstr "PEMVerifier"

#: ../../functions/video/pemverifier.rst:7
msgid ""
"The *PEMVerifier* is used to check for out-of-bounds pixel values during "
"filter development. It is a public function so badly coded filters won't go "
"unnoticed."
msgstr "*PEMVerifier* 用于在滤镜开发期间检查越界像素值。它是一个公共函数，因此编码不当的滤镜不会被忽略。"

#: ../../functions/video/pemverifier.rst:11
msgid ""
"If no values are set, then *upper* and *lower* default to the max and min "
"values allowed in the current format. If an out of bounds value is "
"encountered a frame error is set and the coordinates of the first bad pixel "
"are included in the error message."
msgstr ""
"如果未设置值，则 *upper* 和 *lower* "
"默认为当前格式允许的最大值和最小值。如果遇到超出范围的值，将设置帧错误，并在错误消息中包含第一个坏像素的坐标。"

#: ../../functions/video/planestats.rst:2
msgid "PlaneStats"
msgstr "PlaneStats"

#: ../../functions/video/planestats.rst:7
msgid ""
"This function calculates the min, max and average normalized value of all "
"the pixels in the specified *plane* and stores the values in the frame "
"properties named *prop*\\ Min, *prop*\\ Max and *prop*\\ Average."
msgstr ""
"此函数计算指定 *plane* 中所有像素的最小值、最大值和平均归一化值，并将这些值存储在名为 *prop*\\ Min、*prop*\\ Max 和 "
"*prop*\\ Average 的帧属性中。"

#: ../../functions/video/planestats.rst:11
msgid ""
"If *clipb* is supplied, the absolute normalized difference between the two "
"clips will be stored in *prop*\\ Diff as well."
msgstr "如果提供了 *clipb*，两个片段之间的绝对归一化差异也将存储在 *prop*\\ Diff 中。"

#: ../../functions/video/planestats.rst:14
msgid ""
"The normalization means that the average and the diff will always be floats "
"between 0 and 1, no matter what the input format is."
msgstr "归一化意味着无论输入格式如何，平均值和差异始终是 0 到 1 之间的浮点数。"

#: ../../functions/video/premultiply.rst:2
msgid "PreMultiply"
msgstr "PreMultiply"

#: ../../functions/video/premultiply.rst:7
msgid ""
"PreMultiply simply multiplies *clip* and *alpha* in order to make it more "
"suitable for later operations. This will yield much better results when "
"resizing and a clip with an alpha channel and :doc:`MaskedMerge "
"<maskedmerge>` can use it as input. The *alpha* clip must be the grayscale "
"format equivalent of *clip*."
msgstr ""
"PreMultiply 简单地将 *clip* 和 *alpha* 相乘，使其更适合后续操作。在缩放时这会产生更好的结果，带有 alpha "
"通道的剪辑可以将其作为 :doc:`MaskedMerge <maskedmerge>` 的输入。*alpha* 剪辑必须是 *clip* "
"的等效灰度格式。"

#: ../../functions/video/premultiply.rst:12
msgid ""
"Note that limited range pre-multiplied contents excludes the offset. For "
"example with 8 bit input 60 luma and 128 alpha would be calculated as ((60 -"
" 16) * 128)/255 + 16 and not (60 * 128)/255."
msgstr ""
"注意有限范围预乘内容不包括偏移量。例如，对于 8 位输入，亮度 60 和 alpha 128 的计算方式为 ((60 - 16) * 128)/255 "
"+ 16，而不是 (60 * 128)/255。"

#: ../../functions/video/prewitt_sobel.rst:2
msgid "Prewitt/Sobel"
msgstr "Prewitt/Sobel"

#: ../../functions/video/prewitt_sobel.rst:7
msgid "Creates an edge mask using the Prewitt operator."
msgstr "使用 Prewitt 算子创建边缘蒙版。"

#: ../../functions/video/prewitt_sobel.rst:12
msgid "Creates an edge mask using the Sobel operator."
msgstr "使用 Sobel 算子创建边缘蒙版。"

#: ../../functions/video/prewitt_sobel.rst:24
msgid "*scale*"
msgstr "*scale*"

#: ../../functions/video/prewitt_sobel.rst:25
msgid ""
"Multiply all pixels by scale before outputting. This can be used to increase"
" or decrease the intensity of edges in the output."
msgstr "输出前将所有像素乘以 scale。这可用于增加或减少输出中边缘的强度。"

#: ../../functions/video/proptoclip.rst:2
msgid "PropToClip"
msgstr "PropToClip"

#: ../../functions/video/proptoclip.rst:7
msgid ""
"Extracts a clip from the frames attached to the frame property *prop* in "
"*clip*. This function is mainly used to extract a mask/alpha clip that was "
"stored in another one."
msgstr "从 *clip* 中附加到帧属性 *prop* 的帧中提取片段。此函数主要用于提取存储在另一个片段中的蒙版/alpha 片段。"

#: ../../functions/video/proptoclip.rst:12
msgid "It is the inverse of ClipToProp()."
msgstr "它是 ClipToProp() 的逆操作。"

#: ../../functions/video/removeframeprops.rst:2
msgid "RemoveFrameProps"
msgstr "RemoveFrameProps"

#: ../../functions/video/removeframeprops.rst:7
msgid ""
"Returns *clip* but with all the frame properties named in *props* removed. "
"If *props* is unset them all frame properties are removed."
msgstr "返回 *clip*，但删除 *props* 中指定的所有帧属性。如果 *props* 未设置，则删除所有帧属性。"

#: ../../functions/video/removeframeprops.rst:11
msgid ""
"Note that *props* accepts wildcards (* and ?) which can be very useful if "
"you for example only want to clear properties set by a single filter since "
"they're usually prefixed such as VFM\\* or _\\* can be used as a shorthand "
"to conveniently clear only the internally reserved properties (colorimetry, "
"time, field structure)."
msgstr ""
"注意 *props* 接受通配符（* 和 ?），这非常有用，例如如果你只想清除由单个滤镜设置的属性，因为它们通常有前缀，如 VFM\\* 或 _\\* "
"可用作便捷方式来仅清除内部保留属性（色度学、时间、场结构）。"

#: ../../functions/video/resize.rst:2
msgid "Resize"
msgstr "Resize"

#: ../../functions/video/resize.rst:14
msgid ""
"In VapourSynth the resizers have several functions. In addition to scaling, "
"they also do colorspace conversions and conversions to and from the compat "
"formats. Resize converts a clip of known or unknown format to another clip "
"of known or unknown format, changing only the parameters specified by the "
"user. The resize filters can handle varying size and format input clips and "
"turn them into constant format clips."
msgstr ""
"在 VapourSynth 中，缩放器具有多种功能。除了缩放外，它们还进行色彩空间转换以及与兼容格式之间的转换。Resize "
"将已知或未知格式的剪辑转换为另一个已知或未知格式的剪辑，仅更改用户指定的参数。缩放滤镜可以处理不同尺寸和格式的输入剪辑，并将其转换为固定格式的剪辑。"

#: ../../functions/video/resize.rst:21
msgid ""
"If you do not know which resizer to choose, then try Bicubic. It usually "
"makes a good neutral default."
msgstr "如果你不知道选择哪个调整大小器，试试 Bicubic。它通常是一个很好的中性默认选择。"

#: ../../functions/video/resize.rst:24
msgid "*Bob* can be used as a rudimentary deinterlacer."
msgstr "*Bob* 可用作基本的去隔行器。"

#: ../../functions/video/resize.rst:26
msgid ""
"Arguments denoted as type *enum* may be specified by numerical index (see "
"ITU-T H.273, Video Code Points) or by name. Enums specified by name have "
"their argument name suffixed with \"_s\". For example, a destination matrix "
"of BT 709 can be specified either with ``matrix=1`` or with "
"``matrix_s=\"709\"``."
msgstr ""
"类型标记为 *enum* 的参数可以通过数字索引（参见 ITU-T H.273，视频代码点）或名称指定。通过名称指定的枚举，其参数名称以 \"_s\" "
"为后缀。例如，BT 709 的目标矩阵可以用 ``matrix=1`` 或 ``matrix_s=\"709\"`` 指定。"

#: ../../functions/video/resize.rst:31
msgid ""
"Note that *matrix* is not an optional argument when converting to YUV. Also "
"note that if no matrix is specified in an input YUV frame's properties then "
"*matrix_in* also needs to be set."
msgstr ""
"注意在转换为 YUV 时 *matrix* 不是可选参数。另外注意，如果输入 YUV 帧的属性中未指定矩阵，则还需要设置 *matrix_in*。"

#: ../../functions/video/resize.rst:35
msgid ""
"The function will return an error if the subsampling restrictions aren't "
"followed."
msgstr "如果不遵守子采样限制，函数将返回错误。"

#: ../../functions/video/resize.rst:38
msgid "If you get an error like::"
msgstr "如果你得到如下错误："

#: ../../functions/video/resize.rst:43
msgid ""
"It usually means the matrix/transfer/primaries are unknown and you have to "
"specify the input colorspace parameters yourself. Note: 2 means "
"\"unspecified\" according to the ITU-T recommendation."
msgstr "这通常意味着矩阵/传输/原色未知，你必须自行指定输入色彩空间参数。注意：根据 ITU-T 建议，2 表示「未指定」。"

#: ../../functions/video/resize.rst:47
msgid ""
"Resizing is performed per-field for interlaced images, as indicated by the "
"*_FieldBased* frame property. Source filters may sometimes mark progressive "
"video as interlaced, which can result in sub-optimal resampling quality "
"unless *_FieldBased* is cleared."
msgstr ""
"对于隔行图像，如 *_FieldBased* 帧属性所示，缩放是按场执行的。源滤镜有时可能将逐行视频标记为隔行，这可能导致非最优的重采样质量，除非清除 "
"*_FieldBased*。"

#: ../../functions/video/resize.rst:52
msgid "*clip*:"
msgstr "*clip*："

#: ../../functions/video/resize.rst:54
msgid "Accepts all kinds of input."
msgstr "接受所有类型的输入。"

#: ../../functions/video/resize.rst:56
msgid "*width*, *height*:"
msgstr "*width*、*height*："

#: ../../functions/video/resize.rst:58
msgid "Output image dimensions."
msgstr "输出图像尺寸。"

#: ../../functions/video/resize.rst:60
msgid "*filter*:"
msgstr "*filter*："

#: ../../functions/video/resize.rst:62
msgid ""
"Scaling method for deinterlacing. See *resample_filter_uv* for accepted "
"values."
msgstr "去隔行的缩放方法。参见 *resample_filter_uv* 了解可接受的值。"

#: ../../functions/video/resize.rst:64
msgid "*tff*:"
msgstr "*tff*："

#: ../../functions/video/resize.rst:66
msgid ""
"Field order for deinterlacing. Used when the *_FieldBased* property is not "
"set."
msgstr "去隔行的场顺序。当未设置 *_FieldBased* 属性时使用。"

#: ../../functions/video/resize.rst:68
msgid "*format*:"
msgstr "*format*："

#: ../../functions/video/resize.rst:70
msgid "Output format id."
msgstr "输出格式 ID。"

#: ../../functions/video/resize.rst:72
msgid "*matrix*, *transfer*, *primaries*:"
msgstr "*matrix*、*transfer*、*primaries*："

#: ../../functions/video/resize.rst:74
msgid ""
"Output colorspace specification. If not provided, the corresponding "
"attributes from the input clip will be selected, except for YCoCg and RGB "
"color families, where the corresponding matrix is set by default."
msgstr "输出色彩空间规范。如果未提供，将选择输入剪辑的对应属性，但 YCoCg 和 RGB 色彩族除外，它们默认设置对应的矩阵。"

#: ../../functions/video/resize.rst:78
msgid "*range*:"
msgstr "*range*："

#: ../../functions/video/resize.rst:80
msgid ""
"Output pixel range. For integer formats, this allows selection of the legal "
"code values. Even when set, out of range values (BTB/WTW) may be generated. "
"If the input format is of a different color family, the default range is "
"studio/limited for YUV and full-range for RGB."
msgstr ""
"输出像素范围。对于整数格式，这允许选择合法的代码值。即使设置了，也可能生成超出范围的值 (BTB/WTW)。如果输入格式属于不同的色彩族，YUV "
"的默认范围是 studio/limited，RGB 为 full-range。"

#: ../../functions/video/resize.rst:85
msgid "*chromaloc*:"
msgstr "*chromaloc*："

#: ../../functions/video/resize.rst:87
msgid ""
"Output chroma location. For subsampled formats, specifies the chroma "
"location. If the input format is 4:4:4 or RGB and the output is subsampled, "
"the default location is left-aligned, as per MPEG. Possible chroma locations"
" (ITU-T H.273 Figure 10): *left*, *center*, *top_left*, *top*, "
"*bottom_left*, *bottom*"
msgstr ""
"输出色度位置。对于子采样格式，指定色度位置。如果输入格式是 4:4:4 或 RGB 且输出是子采样的，则默认位置为左对齐，符合 MPEG "
"规范。可选的色度位置（ITU-T H.273 图 "
"10）：*left*、*center*、*top_left*、*top*、*bottom_left*、*bottom*"

#: ../../functions/video/resize.rst:92
msgid ""
"*matrix_in*, *transfer_in*, *primaries_in*, *range_in*, *chromaloc_in*:"
msgstr "*matrix_in*、*transfer_in*、*primaries_in*、*range_in*、*chromaloc_in*："

#: ../../functions/video/resize.rst:94
msgid ""
"Input colorspace/format specification. If the corresponding frame property "
"is set to a value other than unspecified, the frame property is used instead"
" of this parameter. Default values are set for certain color families. See "
"the equivalent output arguments for more information."
msgstr ""
"输入色彩空间/格式规范。如果对应的帧属性设置为非「未指定」的值，则使用帧属性而非此参数。某些色彩族设有默认值。有关更多信息，请参阅等效的输出参数。"

#: ../../functions/video/resize.rst:99
msgid "*filter_param_a*, *filter_param_b*:"
msgstr "*filter_param_a*、*filter_param_b*："

#: ../../functions/video/resize.rst:101
msgid ""
"Parameters for the scaler used for RGB and Y-channel. For the bicubic "
"filter, filter_param_a/b represent the \"b\" and \"c\" parameters. For the "
"lanczos filter, filter_param_a represents the number of taps."
msgstr ""
"用于 RGB 和 Y 通道的缩放器参数。对于双三次滤波器，filter_param_a/b 表示 \"b\" 和 \"c\" 参数。对于 lanczos"
" 滤波器，filter_param_a 表示抽头数。"

#: ../../functions/video/resize.rst:105
msgid "*resample_filter_uv*:"
msgstr "*resample_filter_uv*："

#: ../../functions/video/resize.rst:107
msgid ""
"Scaling method for UV channels. It defaults to the same as for the "
"Y-channel. The following values can be used with *resample_filter_uv*: "
"*point*, *bilinear*, *bicubic*, *spline16*, *spline36*, *lanczos*."
msgstr ""
"UV 通道的缩放方法。默认与 Y 通道相同。以下值可与 *resample_filter_uv* "
"一起使用：*point*、*bilinear*、*bicubic*、*spline16*、*spline36*、*lanczos*。"

#: ../../functions/video/resize.rst:111
msgid "*filter_param_a_uv*, *filter_param_b_uv*:"
msgstr "*filter_param_a_uv*、*filter_param_b_uv*："

#: ../../functions/video/resize.rst:113
msgid "Parameters for the scaler used for UV channels."
msgstr "用于 UV 通道的缩放器参数。"

#: ../../functions/video/resize.rst:115
msgid "*dither_type*:"
msgstr "*dither_type*："

#: ../../functions/video/resize.rst:117
msgid ""
"Dithering method. Dithering is used only for conversions resulting in an "
"integer format. The following dithering methods are available: *none*, "
"*ordered*, *random*, *error_diffusion*."
msgstr ""
"抖动方法。抖动仅用于产生整数格式的转换。可用的抖动方法有：*none*、*ordered*、*random*、*error_diffusion*。"

#: ../../functions/video/resize.rst:121
msgid "*cpu_type*:"
msgstr "*cpu_type*："

#: ../../functions/video/resize.rst:123
msgid "Only used for testing."
msgstr "仅用于测试。"

#: ../../functions/video/resize.rst:125
msgid "*src_left*, *src_top*, *src_width*, *src_height*:"
msgstr "*src_left*、*src_top*、*src_width*、*src_height*："

#: ../../functions/video/resize.rst:127
msgid ""
"Used to select the source region of the input to use. Can also be used to "
"shift the image. Defaults to the whole image."
msgstr "用于选择要使用的输入源区域。也可用于偏移图像。默认为整个图像。"

#: ../../functions/video/resize.rst:130
msgid "*nominal_luminance*:"
msgstr "*nominal_luminance*："

#: ../../functions/video/resize.rst:132
msgid ""
"Determines the physical brightness of the value 1.0. The unit is in cd/m^2."
msgstr "确定值 1.0 的物理亮度。单位为 cd/m^2。"

#: ../../functions/video/resize.rst:134
msgid "*approximate_gamma*:"
msgstr "*approximate_gamma*："

#: ../../functions/video/resize.rst:136
msgid "Use LUT to evaluate transfer functions. Defaults to True."
msgstr "使用 LUT 评估传输函数。默认为 True。"

#: ../../functions/video/resize.rst:138
msgid "To convert to YV12::"
msgstr "转换为 YV12："

#: ../../functions/video/resize.rst:142
msgid ""
"To resize and convert YUV with color information frame properties to planar "
"RGB::"
msgstr "将带有颜色信息帧属性的 YUV 调整大小并转换为平面 RGB："

#: ../../functions/video/resize.rst:146
msgid ""
"To resize and convert YUV without color information frame properties to "
"planar RGB::"
msgstr "将不带颜色信息帧属性的 YUV 调整大小并转换为平面 RGB："

#: ../../functions/video/resize.rst:150
msgid ""
"The following tables list values of selected colorspace enumerations and "
"their abbreviated names. (Numerical value in parentheses.) For all possible "
"values, see ITU-T H.273."
msgstr "以下表格列出了选定色彩空间枚举的值及其缩写名称。（数值在括号中。）有关所有可能的值，请参见 ITU-T H.273。"

#: ../../functions/video/resize.rst:154
msgid "Matrix coefficients (ITU-T H.273 Table 4)::"
msgstr "矩阵系数（ITU-T H.273 表 4）："

#: ../../functions/video/resize.rst:184
msgid "Transfer characteristics (ITU-T H.273 Table 3)::"
msgstr "传输特性（ITU-T H.273 表 3）："

#: ../../functions/video/resize.rst:222
msgid "Color primaries (ITU-T H.273 Table 2)::"
msgstr "色域原色（ITU-T H.273 表 2）："

#: ../../functions/video/resize.rst:263
msgid "Pixel range (ITU-T H.273 equations for matrix coefficients)::"
msgstr "像素范围（ITU-T H.273 矩阵系数方程）："

#: ../../functions/video/reverse.rst:2
msgid "Reverse"
msgstr "Reverse"

#: ../../functions/video/reverse.rst:10
msgid ""
"In Python, std.Reverse can also be invoked by :ref:`slicing a clip "
"<pythonreference>`."
msgstr "在 Python 中，std.Reverse 也可以通过 :ref:`切片 <pythonreference>` 调用。"

#: ../../functions/video/selectevery.rst:2
msgid "SelectEvery"
msgstr "SelectEvery"

#: ../../functions/video/selectevery.rst:7
msgid ""
"Returns a clip with only some of the frames in every *cycle* selected. The "
"*offsets* given must be between 0 and *cycle* - 1."
msgstr "返回每个 *cycle* 中仅选择部分帧的片段。给定的 *offsets* 必须在 0 到 *cycle* - 1 之间。"

#: ../../functions/video/selectevery.rst:12
msgid "Return even numbered frames, starting with 0::"
msgstr "返回偶数编号的帧，从 0 开始："

#: ../../functions/video/selectevery.rst:16
msgid "Return odd numbered frames, starting with 1::"
msgstr "返回奇数编号的帧，从 1 开始："

#: ../../functions/video/selectevery.rst:20
msgid "Fixed pattern 1 in 5 decimation, first frame in every cycle removed::"
msgstr "固定模式 1/5 抽取，每个周期中移除第一帧："

#: ../../functions/video/selectevery.rst:24
msgid "Duplicate every fourth frame::"
msgstr "复制每第四帧："

#: ../../functions/video/selectevery.rst:28
msgid ""
"In Python, std.SelectEvery can also be invoked by :ref:`slicing a clip "
"<pythonreference>`."
msgstr "在 Python 中，std.SelectEvery 也可以通过 :ref:`切片 <pythonreference>` 调用。"

#: ../../functions/video/selectevery.rst:30
msgid ""
"If *modify_duration* is set the clip's frame rate is multiplied by the "
"number of offsets and divided by *cycle*. The frame durations are adjusted "
"in the same manner."
msgstr "如果设置了 *modify_duration*，则剪辑的帧率乘以偏移数量并除以 *cycle*。帧时长以相同方式调整。"

#: ../../functions/video/separatefields.rst:2
msgid "SeparateFields"
msgstr "SeparateFields"

#: ../../functions/video/separatefields.rst:7
msgid "Returns a clip with the fields separated and interleaved."
msgstr "返回场分离并交错的片段。"

#: ../../functions/video/separatefields.rst:9
msgid ""
"The *tff* argument only has an effect when the field order isn't set for a "
"frame. Setting *tff* to true means top field first and false means bottom "
"field first."
msgstr "*tff* 参数仅在未为帧设置场顺序时有效。将 *tff* 设置为 true 表示顶场优先，false 表示底场优先。"

#: ../../functions/video/separatefields.rst:13
msgid ""
"If *modify_duration* is set then the output clip's frame rate is double that"
" of the input clip. The frame durations will also be halved."
msgstr "如果设置了 *modify_duration*，则输出片段的帧率是输入片段的两倍。帧持续时间也将减半。"

#: ../../functions/video/separatefields.rst:16
msgid ""
"The ``_FieldBased`` frame property is deleted. The ``_Field`` frame property"
" is added."
msgstr "``_FieldBased`` 帧属性被删除。添加 ``_Field`` 帧属性。"

#: ../../functions/video/separatefields.rst:19
msgid ""
"If no field order is specified in ``_FieldBased`` or *tff* an error will be "
"returned."
msgstr "如果在 ``_FieldBased`` 或 *tff* 中未指定场顺序，将返回错误。"

#: ../../functions/video/setfieldbased.rst:2
msgid "SetFieldBased"
msgstr "SetFieldBased"

#: ../../functions/video/setfieldbased.rst:7
msgid ""
"This is a convenience function. See *SetFrameProps* if you want to set other"
" properties."
msgstr "这是一个便捷函数。如果要设置其他属性，请参见 *SetFrameProps*。"

#: ../../functions/video/setfieldbased.rst:10
msgid ""
"SetFieldBased sets ``_FieldBased`` to *value* and deletes the ``_Field`` "
"frame property. The possible values are:"
msgstr "SetFieldBased 将 ``_FieldBased`` 设置为 *value* 并删除 ``_Field`` 帧属性。可能的值为："

#: ../../functions/video/setfieldbased.rst:13
msgid "0 = Frame Based"
msgstr "0 = 基于帧（逐行扫描）"

#: ../../functions/video/setfieldbased.rst:15
msgid "1 = Bottom Field First"
msgstr "1 = 底场优先"

#: ../../functions/video/setfieldbased.rst:17
msgid "2 = Top Field First"
msgstr "2 = 顶场优先"

#: ../../functions/video/setfieldbased.rst:19
msgid ""
"For example, if you have source material that's progressive but has been "
"encoded as interlaced you can set it to be treated as frame based (not "
"interlaced) to improve resizing quality::"
msgstr "例如，如果你的源素材是逐行的但已编码为隔行，你可以将其设置为基于帧的（非隔行）处理以提高缩放质量::"

#: ../../functions/video/setframeprop.rst:2
msgid "SetFrameProp"
msgstr "SetFrameProp"

#: ../../functions/video/setframeprop.rst:7
msgid "Adds a frame property to every frame in *clip*."
msgstr "为 *clip* 中的每一帧添加帧属性。"

#: ../../functions/video/setframeprop.rst:9
msgid ""
"If there is already a property with the name *prop* in the frames, it will "
"be overwritten."
msgstr "如果帧中已存在名为 *prop* 的属性，它将被覆写。"

#: ../../functions/video/setframeprop.rst:12
msgid ""
"The type of the property added depends on which of the *intval*, *floatval*,"
" or *data* parameters is used."
msgstr "添加的属性类型取决于使用的是 *intval*、*floatval* 还是 *data* 参数。"

#: ../../functions/video/setframeprop.rst:15
#: ../../functions/video/setframeprops.rst:11
msgid "For example, to set the field order to top field first::"
msgstr "例如，设置场序为顶场优先："

#: ../../functions/video/setframeprops.rst:2
msgid "SetFrameProps"
msgstr "SetFrameProps"

#: ../../functions/video/setframeprops.rst:7
msgid ""
"Adds the specified values as a frame property of every frame in *clip*. If a"
" frame property with the same key already exists it will be replaced."
msgstr "将指定的值作为帧属性添加到 *clip* 的每一帧。如果已存在具有相同键的帧属性，它将被替换。"

#: ../../functions/video/setvideocache.rst:2
msgid "SetVideoCache"
msgstr "SetVideoCache"

#: ../../functions/video/setvideocache.rst:7
msgid ""
"Every filter node has a cache associated with it that may or may not be "
"enabled depending on the dependencies and request patterns. This function "
"allows all automatic behavior to be overridden."
msgstr "每个滤镜节点都有一个与之关联的缓存，根据依赖关系和请求模式可能启用或不启用。此函数允许覆盖所有自动行为。"

#: ../../functions/video/setvideocache.rst:12
msgid ""
"The *mode* option has 3 possible options where 0 always disables caching, 1 "
"always enables the cache and -1 uses the automatically calculated settings. "
"Note that setting *mode* to -1 will reset the other values to their defaults"
" as well."
msgstr ""
"*mode* 选项有 3 个可能的值，0 始终禁用缓存，1 始终启用缓存，-1 使用自动计算的设置。注意将 *mode* 设置为 -1 "
"也会将其他值重置为默认值。"

#: ../../functions/video/setvideocache.rst:18
msgid ""
"The other options are fairly self-explanatory where setting *fixedsize* "
"prevents the cache from over time altering its *maxsize* based on request "
"history. The final *historysize* argument controls how many previous and no "
"longer cached requests should be considered when adjusting *maxsize*, "
"generally this value should not be touched at all."
msgstr ""
"其他选项相当不言自明，设置 *fixedsize* 可防止缓存根据请求历史随时间改变其 *maxsize*。最后的 *historysize* "
"参数控制在调整 *maxsize* 时应考虑多少个先前且不再缓存的请求，通常不应该修改此值。"

#: ../../functions/video/setvideocache.rst:26
msgid ""
"Note that setting *mode* will reset all other options to their defaults."
msgstr "请注意，设置 *mode* 将重置所有其他选项为默认值。"

#: ../../functions/video/shuffleplanes.rst:2
msgid "ShufflePlanes"
msgstr "ShufflePlanes"

#: ../../functions/video/shuffleplanes.rst:7
msgid ""
"ShufflePlanes can extract and combine planes from different clips in the "
"most general way possible. This is both good and bad, as there are almost no"
" error checks."
msgstr "ShufflePlanes 可以以最通用的方式从不同片段中提取和组合平面。这既是优点也是缺点，因为几乎没有错误检查。"

#: ../../functions/video/shuffleplanes.rst:11
msgid ""
"Most of the returned clip's properties are implicitly determined from the "
"first clip given to *clips* but can also be changed by using *prop_src*."
msgstr "返回片段的大多数属性由给定到 *clips* 的第一个片段隐式确定，但也可以通过使用 *prop_src* 更改。"

#: ../../functions/video/shuffleplanes.rst:14
msgid ""
"The *clips* parameter takes between one and three clips for color families "
"with three planes. In this case clips=[A] is equivalent to clips=[A, A, A] "
"and clips=[A, B] is equivalent to clips=[A, B, B]. For the GRAY color "
"family, which has one plane, it takes exactly one clip."
msgstr ""
"*clips* 参数对于具有三个平面的色彩族取一到三个剪辑。在这种情况下 clips=[A] 等同于 clips=[A, A, A]，clips=[A,"
" B] 等同于 clips=[A, B, B]。对于只有一个平面的 GRAY 色彩族，恰好取一个剪辑。"

#: ../../functions/video/shuffleplanes.rst:19
msgid ""
"The argument *planes* controls which of the input clips' planes to use. Zero"
" indexed. The first number refers to the first input clip, the second number"
" to the second clip, the third number to the third clip."
msgstr ""
"参数 *planes* 控制使用输入剪辑的哪些平面。从零开始索引。第一个数字指第一个输入剪辑，第二个数字指第二个剪辑，第三个数字指第三个剪辑。"

#: ../../functions/video/shuffleplanes.rst:23
msgid ""
"The only thing that needs to be specified is *colorfamily*, which controls "
"which color family (YUV, RGB, GRAY) the output clip will be. Properties such"
" as subsampling are determined from the relative size of the given planes to"
" combine."
msgstr ""
"唯一需要指定的是 *colorfamily*，它控制输出剪辑的色彩族（YUV、RGB、GRAY）。子采样等属性由要组合的给定平面的相对尺寸决定。"

#: ../../functions/video/shuffleplanes.rst:28
msgid ""
"ShufflePlanes accepts clips with variable format and dimensions only when "
"extracting a single plane."
msgstr "ShufflePlanes 仅在提取单个平面时接受具有可变格式和维度的片段。"

#: ../../functions/video/shuffleplanes.rst:33
msgid ""
"Extract plane with index X. X=0 will mean luma in a YUV clip and R in an RGB"
" clip. Likewise 1 will return the U and G channels, respectively::"
msgstr "提取索引为 X 的平面。X=0 在 YUV 片段中表示亮度，在 RGB 片段中表示 R。类似地，1 分别返回 U 和 G 通道："

#: ../../functions/video/shuffleplanes.rst:38
msgid "Swap U and V in a YUV clip::"
msgstr "交换 YUV 片段中的 U 和 V："

#: ../../functions/video/shuffleplanes.rst:42
msgid "Merge 3 grayscale clips into a YUV clip::"
msgstr "将 3 个灰度片段合并为一个 YUV 片段："

#: ../../functions/video/shuffleplanes.rst:46
msgid "Cast a YUV clip to RGB::"
msgstr "将 YUV 片段转换为 RGB："

#: ../../functions/video/splice.rst:2
msgid "Splice"
msgstr "Splice"

#: ../../functions/video/splice.rst:9
msgid ""
"Splicing clips with different formats or dimensions is considered an error "
"unless *mismatch* is true."
msgstr "拼接不同格式或维度的片段将被视为错误，除非 *mismatch* 为 true。"

#: ../../functions/video/splice.rst:12
msgid ""
"In Python, std.Splice can also be invoked :ref:`using the addition operator "
"<pythonreference>`."
msgstr "在 Python 中，std.Splice 也可以通过 :ref:`加法运算符 <pythonreference>` 调用。"

#: ../../functions/video/splitplanes.rst:2
msgid "SplitPlanes"
msgstr "SplitPlanes"

#: ../../functions/video/splitplanes.rst:7
msgid "SplitPlanes returns each plane of the input as separate clips."
msgstr "SplitPlanes 将输入的每个平面作为单独的片段返回。"

#: ../../functions/video/stackvertical_stackhorizontal.rst:2
msgid "StackVertical/StackHorizontal"
msgstr "StackVertical/StackHorizontal"

#: ../../functions/video/stackvertical_stackhorizontal.rst:8
msgid ""
"Stacks all given *clips* together. The same format is a requirement. For "
"StackVertical all clips also need to be the same width and for "
"StackHorizontal all clips need to be the same height."
msgstr ""
"将所有给定的 *clips* 堆叠在一起。要求相同的格式。StackVertical 还要求所有片段宽度相同，StackHorizontal "
"要求所有片段高度相同。"

#: ../../functions/video/stackvertical_stackhorizontal.rst:12
msgid "The frame properties are copied from the first clip."
msgstr "帧属性从第一个片段复制。"

#: ../../functions/video/text/clipinfo.rst:2
msgid "ClipInfo"
msgstr "ClipInfo"

#: ../../functions/video/text/clipinfo.rst:7
msgid "Prints information about the *clip*, such as the format and framerate."
msgstr "打印关于 *clip* 的信息，如格式和帧率。"

#: ../../functions/video/text/clipinfo.rst:9
#: ../../functions/video/text/coreinfo.rst:10
#: ../../functions/video/text/framenum.rst:9
#: ../../functions/video/text/frameprops.rst:10
msgid "This is a convenience function for *Text*."
msgstr "这是 *Text* 的便捷函数。"

#: ../../functions/video/text/coreinfo.rst:2
msgid "CoreInfo"
msgstr "CoreInfo"

#: ../../functions/video/text/coreinfo.rst:7
msgid ""
"Prints information about the VapourSynth core, such as version and memory "
"use. If no *clip* is supplied, a default blank one is used."
msgstr "打印 VapourSynth 核心信息，如版本和内存使用情况。如果未提供 *clip*，将使用默认的空白片段。"

#: ../../functions/video/text/framenum.rst:2
msgid "FrameNum"
msgstr "FrameNum"

#: ../../functions/video/text/framenum.rst:7
msgid "Prints the current frame number."
msgstr "打印当前帧号。"

#: ../../functions/video/text/frameprops.rst:2
msgid "FrameProps"
msgstr "FrameProps"

#: ../../functions/video/text/frameprops.rst:7
msgid ""
"Prints all properties attached to the frames, or if the *props* array is "
"given only those properties."
msgstr "打印附加到帧的所有属性，如果给定了 *props* 数组，则仅打印这些属性。"

#: ../../functions/video/text/text.rst:7
msgid ""
"Text is a simple text printing filter. It doesn't use any external libraries"
" for drawing the text. It uses a built-in bitmap font: the not-bold, 8×16 "
"version of Terminus. The font was not modified, only converted from PCF to "
"an array of bytes."
msgstr ""
"Text 是一个简单的文字打印滤镜。它不使用任何外部库来绘制文字。它使用内置的点阵字体：Terminus 的非粗体 8×16 版本。字体未经修改，仅从 "
"PCF 转换为字节数组。"

#: ../../functions/video/text/text.rst:12
msgid ""
"The font covers Windows-1252, which is a superset of ISO-8859-1 (aka "
"latin1). Unprintable characters get turned into underscores. Long lines get "
"wrapped in a dumb way. Lines that end up too low to fit in the frame are "
"silently dropped."
msgstr ""
"字体覆盖 Windows-1252，它是 ISO-8859-1（又名 "
"latin1）的超集。不可打印字符会转换为下划线。长行以简单方式换行。最终位置过低而无法放入帧中的行将被静默丢弃。"

#: ../../functions/video/text/text.rst:17
msgid ""
"The *alignment* parameter takes a number from 1 to 9, corresponding to the "
"positions of the keys on a numpad."
msgstr "*alignment* 参数接受 1 到 9 的数字，对应数字小键盘上按键的位置。"

#: ../../functions/video/text/text.rst:20
msgid ""
"The *scale* parameter sets an integer scaling factor for the bitmap font."
msgstr "*scale* 参数为位图字体设置整数缩放因子。"

#: ../../functions/video/text/text.rst:22
msgid ""
"*ClipInfo*, *CoreInfo*, *FrameNum*, and *FrameProps* are convenience "
"functions based on *Text*."
msgstr "*ClipInfo*、*CoreInfo*、*FrameNum* 和 *FrameProps* 是基于 *Text* 的便捷函数。"

#: ../../functions/video/transpose.rst:2
msgid "Transpose"
msgstr "Transpose"

#: ../../functions/video/transpose.rst:7
msgid ""
"Flips the contents of the frames in the same way as a matrix transpose would"
" do. Combine it with FlipVertical or FlipHorizontal to synthesize a left or "
"right rotation. Calling Transpose twice in a row is the same as doing "
"nothing (but slower)."
msgstr ""
"以矩阵转置的方式翻转帧的内容。将其与 FlipVertical 或 FlipHorizontal 组合可实现左旋或右旋。连续调用 Transpose "
"两次等同于不做任何操作（但更慢）。"

#: ../../functions/video/transpose.rst:12
msgid "Here is a picture to illustrate what Transpose does::"
msgstr "以下是说明 Transpose 操作的图示："

#: ../../functions/video/trim.rst:2
msgid "Trim"
msgstr "Trim"

#: ../../functions/video/trim.rst:7
msgid ""
"Trim returns a clip with only the frames between the arguments *first* and "
"*last*, or a clip of *length* frames, starting at *first*. Trim is inclusive"
" so Trim(clip, first=3, last=3) will return one frame. If neither *last* nor"
" *length* is specified, no frames are removed from the end of the clip."
msgstr ""
"Trim 返回仅包含参数 *first* 和 *last* 之间帧的剪辑，或从 *first* 开始的 *length* 帧的剪辑。Trim "
"是包含性的，因此 Trim(clip, first=3, last=3) 将返回一帧。如果既未指定 *last* 也未指定 "
"*length*，则不会从剪辑末尾删除帧。"

#: ../../functions/video/trim.rst:13
msgid ""
"Specifying both *last* and *length* is considered to be an error. Likewise "
"is calling Trim in a way that returns no frames, as 0 frame clips are not "
"allowed in VapourSynth."
msgstr ""
"同时指定 *last* 和 *length* 被视为错误。同样，以不返回任何帧的方式调用 Trim 也是错误的，因为 VapourSynth 不允许 0"
" 帧片段。"

#: ../../functions/video/trim.rst:17
msgid ""
"In Python, std.Trim can also be invoked by :ref:`slicing a clip "
"<pythonreference>`."
msgstr "在 Python 中，std.Trim 也可以通过 :ref:`切片 <pythonreference>` 调用。"

#: ../../functions/video/turn180.rst:2
msgid "Turn180"
msgstr "Turn180"

#: ../../functions/video/turn180.rst:7
msgid ""
"Turns the frames in a clip 180 degrees (to the left, not to the right)."
msgstr "将片段中的帧旋转 180 度（向左，不是向右）。"
